#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long qw(GetOptions);

##################################################
sub usage(){
print qq*
$0 -- cleanup photoalbum

Usage:
  $0 <options> <infile>

Options:
    -h,--help    -- display help screen
    -q,--quiet   -- be quiet, do not list files
    -f,--force   -- remove without asking
    -d --dryrun  -- list files but remove nothing

Report bugs to <slazav\@altlinux.org>
*;
exit(1);
}

##################################################

## split path into full directory name + basename + last extension
## './some/path/file.e1.e2.ext' -> './some/path/' + 'file.e1.e2' + '.ext'
sub path_split($){
  $_[0]=~m&(.*\/)?((.*)(\..*)|(.*)())&;
  return (($1 or ''), ($3 or $5 or ''), ($4 or $6 or ''));
}

## list all files in the directory
sub read_dir{
  my @ret;
  my $dir   = shift;
  unless(opendir D, $dir){
    warn "Skipping unreadable directory $dir: $!\n";
    return;
  }
  my @list = readdir D;
  closedir D;

  foreach (@list){
    next if /^\.{1,2}$/;
    my $f = "$dir/$_";
    push(@ret, (-d $f)? read_dir($f) : $f);
  }
  return @ret;
}

##################################################

### get options 
my %opts;
GetOptions(
  "h|help"     => \$opts{help},
  "q|quiet"    => \$opts{quiet},
  "f|force"    => \$opts{force},
  "d|dryrun"   => \$opts{dryrun},
) or usage();

usage() if $opts{help} || @ARGV!=1;
$opts{infile} = shift;
die "error: can't find file: $opts{infile}\n" unless -f $opts{infile};

# regular expressions for addphoto commands
my $ph_re='^\\\photo([lr]?)\s+(\S+)\s*(.*)';

my ($dir, $base, $ext) = path_split($opts{infile});

### collect files to keep from album index
my %keep;
open IN, $opts{infile} or die "error: can't open file $opts{infile}: $!\n";
foreach(<IN>){
  if (/$ph_re/){     # images
    $keep{"$dir$base/$2"} = 1;

    ## TODO: ask addphoto_www for files related to the image
    my ($d, $b, $e) = path_split($2);
    # add html and thumbnail for this image
    $keep{"$dir$base/$d$b.htm"} = 1;
    $keep{"$dir$base/${d}_$b$e"} = 1;
    # add mark files
    $keep{"$dir$base/$d${b}_m$e"} = 1 if -f "$dir$base/$d$b.fig";
  }
  elsif (/^\\keep\s+(.*)/){  # keep command
    $keep{$_} = 1 foreach (glob "$dir$base/$1");
  }
}

### get files to delete
my @del;
foreach(read_dir "$dir$base"){
  push(@del, $_) unless exists($keep{$_});
}

exit 0 if $#del<0;

### print file list
if (!$opts{quiet}){
  printf STDERR "Files to remove (%d):\n", $#del+1;
  print STDERR join("\n", sort @del), "\n";
}

### ask question
if (!$opts{force} && !$opts{dryrun}){
  print STDERR "Remove these files (y|N)? ";
  $opts{dryrun} = 1 unless getc =~ /y/i;
}

### remove files
if (!$opts{dryrun}){
  printf STDERR "Files have been removed.\n", $#del+1;
  unlink foreach @del;
}
