#!/usr/bin/perl

use strict;
use addphoto;
use warnings;
use Getopt::Long qw(GetOptions);

##################################################
sub usage(){
print qq*
$0 -- cleanup photoalbum

Usage:
  $0 <options> <infile>

Options:
    -h,--help    -- display help screen
    -q,--quiet   -- be quiet, do not list files
    -f,--force   -- remove without asking
    -d --dryrun  -- list files but remove nothing

Report bugs to <slazav\@altlinux.org>
*;
exit(1);
}

##################################################

### get options 
my %opts;
GetOptions(
  "h|help"     => \$opts{help},
  "q|quiet"    => \$opts{quiet},
  "f|force"    => \$opts{force},
  "d|dryrun"   => \$opts{dryrun},
) or usage();

usage() if $opts{help} || @ARGV!=1;
$opts{infile} = shift;
die "can't find file: $opts{infile}\n"
  unless -f $opts{infile};

# regular expressions for addphoto commands
my $ph_re='^\\\photo([lr]?)\s+(\S+)\s*(.*)';

my ($dir, $base, $ext) = addphoto::path_split($opts{infile});

### collect files to keep from album index
my %keep;
open IN, $opts{infile} or
  die "can't open $opts{infile}: $!\n";
foreach(<IN>){
  if (/$ph_re/){     # images
    $keep{"$dir$base/$2"} = 1;

    ## TODO: ask addphoto_www for files related to the image
    my ($d, $b, $e) = addphoto::path_split($2);
    # add html and thumbnail for this image
    $keep{"$dir$base/$d$b.htm"} = 1;
    $keep{"$dir$base/${d}_$b$e"} = 1;
    # add mark files
    $keep{"$dir$base/$d${b}_m$e"} = 1 if -f "$dir$base/$d$b.fig";
  }
  elsif (/^\\keep\s+(.*)/){  # keep command
    $keep{$_} = 1 foreach (glob "$dir$base/$1");
  }
}

### get files to delete
my @del;
foreach(addphoto::read_dir "$dir$base"){
  push(@del, $_) unless exists($keep{$_});
}

exit 0 if $#del<0;

### print file list
if (!$opts{quiet}){
  printf STDERR "Files to remove (%d):\n", $#del+1;
  print STDERR join("\n", sort @del), "\n";
}

### ask question
if (!$opts{force} && !$opts{dryrun}){
  print STDERR "Remove these files (y|N)? ";
  $opts{dryrun} = 1 unless getc =~ /y/i;
}

### remove files
if (!$opts{dryrun}){
  printf STDERR "Files have been removed.\n", $#del+1;
  unlink foreach @del;
}
