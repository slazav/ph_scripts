#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use Digest::MD5;

#################################################################
### get options 
my %opts = (
  verbose          => 0,
  imgdir           => '.',
  init_img_mask    => '(.jpe?g$)|(.png$)|(.tiff?$)|(.gif)$',
  init_index_head  => "<html><body>\n",
  init_index_tail  => "</body></html>\n",
  init_width       => 800,
  init_days        => 1,
  th1_pref         => '_',
  th1_size         => '260:160:800',
  th1_rm_exif      => 1,
  th2_pref         => '',
  th2_size         => '800:600:1600',
  th2_rm_exif      => 1,
  mark_pref        => '_',
  html_pref         => '',
  quality          => 90,
  map_ref          => 'nakarte',
  map_zoom         => 6,
  fig_lang         => 'ru_RU.KOI8-R',
  html_charset     => 'koi8-r',
  html_viewport    => 1,
  html_screen_sw   => 1,
  html_arrows      => 1,
  mstyle           => 'aa_gif',
  fig_res          => 14.2875, # convert pixel -> fig units
);
my %re = (
 photo => '^\\\photo([lr]?)\s+(\S+)\s*(.*)',
 head  => '^\\\h([1-4])(r?)\s+(.*)',
 keep  => '^\\\keep\s+(.*)',
 set   => '^\\\set\s+(\S+)\s+(.*)',
);
Getopt::Long::Configure("no_ignore_case");
Getopt::Long::GetOptions(
  "h|help"          => \$opts{help},         # print help message
  "v|verbose:1"     => \$opts{verbose},      # be verbose
  "D|imgdir=s"      => \$opts{imgdir},       # image dir (relative to index file location, default .)
  "H|html=s"        => \$opts{html},         # html file (relative to index file location)
  "html_filter=s"   => \$opts{html_filter},  # filter for index html
  "html_stdout:1"   => \$opts{html_stdout},  # print index html to stdout instead of writing to file. html option is still needed.
  "I|init"          => \$opts{init},         # INIT MODE: create index file
  "J|init_only"     => \$opts{init_only},    # create index file and exit
  "T|init_tsort:1"  => \$opts{init_tsort},   # init mode: sort photos by time
  "d|init_days:1"   => \$opts{init_days},    # init mode: add day headers
  "r|init_rec:1"    => \$opts{init_rec},     # init mode: find files recursively
  "w|init_width=i"  => \$opts{init_width},         # init mode: max page width
  "init_img_mask=s" => \$opts{init_img_mask},      # init mode: mask for finding images
  "init_index_head=s"  => \$opts{init_index_head}, # init mode: head for the index file
  "init_index_tail=s"  => \$opts{init_index_tail}, # init mode: tail for the index file
  "C|cleanup"       => \$opts{cleanup},      # CLEANUP MODE: remove unused files and exit
  "f|force:1"       => \$opts{force},        # cleanup mode: do not ask before deleting files
  "th1_pref=s"      => \$opts{th1_pref},     # Small thumbnail prefix (can end with /), empty for no thumbnails
  "th1_size=s"      => \$opts{th1_size},     # Small thumbnail size (S1:S2:S3, see elsewhere)
  "th1_rm_exif:1"   => \$opts{th1_rm_exif},  # Remove exif-data from small thumbnails (default)
  "th2_pref=s"      => \$opts{th2_pref},     # Large thumbnail prefix (can and with /), empty for no thumbnails
  "th2_size=s"      => \$opts{th2_size},     # Large thumbnail size (S1:S2:S3, see elsewhere)
  "th2_rm_exif:1"   => \$opts{th2_rm_exif},  # Remove exif-data from large thumbnails (default)
  "mark_pref=s"     => \$opts{mark_pref},    # Image marks prefix (can and with /), empty for no marks
  "html_pref=s"     => \$opts{html_pref},    # Image marks prefix (can and with /), empty for no marks
  "nohtml:1"        => \$opts{nohtml},       # Do not generate hmtl pages for images
  "mstyle=s"        => \$opts{mstyle},       # Mark style
  "l|lang:1"        => \$opts{lang},         # Language support
  "pswp:1"          => \$opts{pswp},         # PhotoSwipe support
  "quality=i"       => \$opts{quality},      # Jpeg quality for thumbnails (default 90)
  "map_ref=s"       => \$opts{map_ref},      # Map link style (gmap, nakarte)
  "map_zoom=i"      => \$opts{map_zoom},     # Map link zoom (default 6)
  "fig_lang=s"      => \$opts{fig_lang},     # fig language
  "fig_res=f"       => \$opts{fig_res},      # fig resolution
  "html_charset=s"  => \$opts{html_charset}, # add meta charset tag in html pages (not in index html)
  "html_viewport:1" => \$opts{html_viewport},# add meta viewport tag in html pages (not in index html)
  "html_screen_sw:1"=> \$opts{html_screen_sw}, # add "fit to screen" switch to html pages
  "html_arrows:1"   => \$opts{html_arrows},  # add left/right arrow navigation to html pages
) or pod2usage(1);

my $html_version = '2.3'; # changes when regenerating of html pages is needed


pod2usage(-exitval => 0, -verbose => 2) if $opts{help};
pod2usage(1) if @ARGV!=1;

# index file name
$opts{infile} = shift;

# basedir (where infile located)
$opts{basedir} = $opts{infile};
$opts{basedir} =~ s/[^\/]*$//;
$opts{basedir} =~ s|/+$||; # remove trailing /
$opts{basedir} = '.' if $opts{basedir} eq '';

if (-d $opts{infile}){
  $opts{imgdir} = $opts{infile};
  $opts{imgdir} =~ s/.*\///; # remove path
  $opts{infile} .= '.txt';
}

# html file name (relative to index file, can be changed later)
unless ($opts{html}){
  $opts{html} = $opts{infile};
  $opts{html} =~ s/\.[^\.]*$/.htm/;
}

#################################################################
#### FILE AND PATH FUNCTIONS

#################################################################
## list all files in the directory.
sub read_dir{
  my @ret;
  my $dir   = shift;         # base dir
  my $rec   = shift || 0;    # recursive?
  my $retdir  = shift || ''; # inclure dir into return?
  unless(opendir D, $dir){
    warn "Skipping unreadable directory: $dir: $!\n";
    return;
  }
  my @list = readdir D;
  closedir D;

  foreach my $f (@list){
    next if $f =~ /^\.{1,2}$/;
    my $df = "$dir/$f";
    push(@ret, $retdir.$f) if (-f $df);
    push(@ret, read_dir($df,$rec,$retdir.$f.'/')) if -d $df && $rec;
  }
  return @ret;
}

## Do we need to update file1 from file2
## (is it older or does not exist)?
sub isolder($$){
  return 0 if (!-r $_[1]);
  return 1 if (!-r $_[0]);
  return (stat $_[0])[9] < (stat $_[1])[9];
}

## split path into full directory name + basename + last extension
## './some/path/file.e1.e2.ext' -> './some/path/' + 'file.e1.e2' + '.ext'
sub path_split($){
  $_[0]=~m&(.*\/)?((.*)(\..*)|(.*)())&;
  return (($1 or ''), ($3 or $5 or ''), ($4 or $6 or ''));
}

## Get relative path from dir1 to dir2.
## Absolute paths, . and .. are ignored!
sub rel_dir($$){
  my @d1 = grep {/.+/ && !/^\.{1,2}$/} split '/', shift;
  my @d2 = grep {/.+/ && !/^\.{1,2}$/} split '/', shift;
  my $n;
  for ($n = 0; $n <= $#d1 && $n <= $#d2; $n++){
    last if ($d1[$n] ne $d2[$n])
  }
  my $ret='';
  $ret .= "../" foreach @d1[$n..$#d1];
  $ret .= "$_/" foreach @d2[$n..$#d2];
  return $ret;
}

#################################################################
#### IMAGE SIZE FUNCTIONS

## get image size (identify from ImageMagick is needed).
sub image_size($){
  `identify "$_[0]" 2> /dev/null` =~/(\d+)x(\d+)/;
  return ($1 || 0, $2 || 0);
}

## calculate rescaling factor:
# - "Usual" images will be scaled to fit into S1xS1 square;
# - long images will not be smaller then S2 on short edge;
# - very long images will not be larger than S3 on long edge;
# - small images will not be modified.
sub image_scfactor($$$$$){
  my ($x, $y, $m1, $m2, $m3) = @_;
  $x=1.0*$x; $y=1.0*$y;

  my $kx = $x/$m1;
  my $ky = $y/$m1;

  my $k = $kx>$ky ? $kx:$ky;

  $k = $x/$m2 if $x/$k < $m2;
  $k = $y/$m2 if $y/$k < $m2;

  $k = $x/$m3 if $x/$k > $m3;
  $k = $y/$m3 if $y/$k > $m3;

  $k = 1 if $k<=1;
  return $k;
}

## get fig image dimensions in "pixels"
sub fig_im_scale($$){
  my ($figpath, $img) = @_;
  my ($w, $h) = image_size($img);
  $img=~s|.*/||;
  my $fh;
  open $fh, $figpath or return (0,0);
  while (readline $fh){
    next unless (/^\s+\d+\s+$img/);
    readline($fh) =~
      /^\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)/;
    my @x=sort($1, $3, $5, $7);
    my @y=sort($2, $4, $6, $8);


    my $fw = abs($x[3]-$x[1])/$opts{fig_res};
    my $fh = abs($y[3]-$y[1])/$opts{fig_res};
    return ($h/$fh + $w/$fw) / 2;
  }
  return 0;
}

#################################################################
#### HTML writing functions

## remove html tags from text, for html alt atribute
sub rem_html($){
  my $t=shift;
  $t=~s/<[^>]*>//g;
  $t=~s/[<>\']//g;
  return $t;
}

## create table of contents
## input: array of hashes with fields 'depth' and 'title'
sub html_toc($$){
  my $fh = shift;
  my $hh = shift;
  my $dp=0; # prev depth
  my $d0=0; # initial depth
  for (my $i=0; $i<@{$hh}; $i++){
    my $d=$hh->[$i]->{depth};
    my $t=$hh->[$i]->{title};

    if ($dp==$d0){
      $dp=$d0=$d-1;
    }
    for (;$dp<$d;$dp++) {print $fh '  'x($dp-1) . "<ul>\n";}
    for (;$dp>$d;$dp--) {print $fh '  'x($dp-2) . "</ul>\n";}
    print $fh '  'x($d-1) . "<li><a href=\"#h". ($i+1). "\">$t</a>\n";
  }
  for (;$dp>$d0;$dp--) {print $fh '  'x($dp-2) . "</ul>\n";}
}

#################################################################
#### EXIF functions

## Get exif-data as a hash, convert some values to human-readable form.
## Returns hash ref with original exif fields and some converted fields:
##  dat -- Exif.Photo.DateTimeOriginal or Exif.Image.DateTime,
##  lon, lat, alt -- coordinates, altitude.
## exiv2 program is needed.
sub get_exif{
  my $file=shift;
  my $exif;
  my $n;
  # parse values from exiv2 output.
  foreach (`exiv2 -Pkv $file 2>/dev/null`){
    chomp;
    my ($k, $v) = split(/\s+/,$_,2);
    $exif->{$k}=$v if $v && $k;
  }

  my ($time, $alt, $lat, $lon);
  # DateTime: convert 2009:10:20 10:11:12 -> 2009/10/20 10:11:12
  foreach $n ('Exif.Image.DateTime',
              'Exif.Photo.DateTimeOriginal'){
    if ((exists $exif->{$n}) && ($exif->{$n} =~ /^(\d+):(\d+):(\d+)\s+(\d+):(\d+):(\d+)/)){
      $time = "$1/$2/$3 $4:$5:$6"; }
  }

  # convert alt, lat, lon
  $n='Exif.GPSInfo.GPSAltitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)/)){
    $alt = 1.0*$1/$2;
    $alt=-$alt if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}!=0);
  }
  $n='Exif.GPSInfo.GPSLatitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)\s+(\d+)\/(\d+)\s+(\d+)\/(\d+)/)){
    $lat = 1.0*$1/$2 + 1.0/60.0*$3/$4 + 1.0/3600.0*$5/$6;
    $lat=-$lat if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}=~/^S/);
  }
  $n='Exif.GPSInfo.GPSLongitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)\s+(\d+)\/(\d+)\s+(\d+)\/(\d+)/)){
    $lon = sprintf "%.7f", 1.0*$1/$2 + 1.0/60.0*$3/$4 + 1.0/3600.0*$5/$6;
    $lon=-$exif->{lon} if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}=~/^W/);
  }
  return ($time, $alt, $lat, $lon);
}


#################################################################
#### THUMBNAIL MARKS
## Thumbnail images can is marked with red dot if there are
## some marks on the image. The mark is also kept in the jpeg comment
## These two functions can add and check mark. For remothing mark
## just regenerate thumbnail...
## exiv2 and mogrify (from ImageMagick) programs are needed.
sub thmark_add($){
  my $f=shift;
  `mogrify -fill red -draw 'circle 10,10,12,12' "$f"`;
  `exiv2 -c "<marked>" "$f" 2>/dev/null`;
}
sub thmark_check($){
  my $f=shift;
  return -r $f && `exiv2 -pc "$f" 2>/dev/null` =~ /<marked>/;
}

#################################################################
## HTML messages

my %msgs_ru = (
  dat_fmt  => 'Дата и время съемки:',
  alt_fmt  => 'Высота, м:',
  crd_fmt  => 'Координаты:',
  pref     => '&lt;&lt; предыдущая',
  uref     => 'к оглавлению',
  nref     => 'следующая &gt;&gt;',
  fullsize => 'полный размер',
  sw_size  => 'размер',
  sw_mark  => 'отметки',
);

my %msgs_en = (
  dat_fmt  => 'Date and time:',
  alt_fmt  => 'Altitude, m:',
  crd_fmt  => 'Latitude and longitude:',
  pref     => '&lt;&lt; prev.',
  uref     => 'up',
  nref     => 'next &gt;&gt;',
  fullsize => 'full size',
  sw_size  => 'size',
  sw_mark  => 'marks',
);

sub get_msg($){
  my $id = shift;
  return "<div class=ru>$msgs_ru{$id}</div><div class=en>$msgs_en{$id}</div>"
      if $opts{lang};
  return $msgs_ru{$id};
}

## print latlon coords with or without referense to google/nakarte
sub html_crd($$$){
  my ($lat, $lon, $name) = @_;
  my $style = $opts{map_ref};
  my $zoom  = $opts{map_zoom};
  if ($style eq 'gmap'){
    return sprintf('<a href="http://maps.google.com?t=h&' .
                   'q=%.7f+%.7f&ll=%.7f,%.7f&z=%d">%.7f %.7f</a><br/>',
                    $lat, $lon, $lat, $lon, $zoom, $lat, $lon);
  }
  if ($style eq 'nakarte'){
    return sprintf('<a href="https://nakarte.me/#m=%d/%f/%f&nktp=%f/%f/%s&l=O">%.7f %.7f</a><br/>',
                    $zoom, $lat, $lon, $lat, $lon, $name, $lat, $lon);
  }
  return sprintf('%.7f %.7f', $lat, $lon);
}

#################################################################
#################################################################
# INIT call - do index file, then continue as usual
if ($opts{init} || $opts{init_only}){

  print STDERR "[Creating index file...]\n" if $opts{verbose};
  die "can't find base folder: $opts{basedir}\n"
    unless -d $opts{basedir};

  die "can't find image folder: $opts{basedir}/$opts{imgdir}\n"
    unless -d "$opts{basedir}/$opts{imgdir}";

  ## get image file list
  my @files = grep {/$opts{init_img_mask}/i}
    read_dir("$opts{basedir}/$opts{imgdir}", $opts{init_rec});

  ## remove thumbnail, mark, html files from the list
  @files = grep {!/^$opts{th1_pref}.+$opts{init_img_mask}|\/$opts{th1_pref}.+$opts{init_img_mask}/i} @files
    if $opts{th1_pref};
  @files = grep {!/^$opts{th2_pref}.+$opts{init_img_mask}|\/$opts{th2_pref}.+$opts{init_img_mask}/i} @files
    if $opts{th2_pref};
  @files = grep {!/^$opts{mark_pref}.+$opts{init_img_mask}|\/$opts{mark_pref}.+$opts{init_img_mask}/i} @files
    if $opts{mark_pref};

  ## collect information about files: date, time, thumbnail width
  my %files;
  foreach my $file (@files) {
    my $path = "$opts{basedir}/$opts{imgdir}/$file";

    # get width of small thumbnail (it can be missing!)
    my ($ret, $w, $h) =
      split(/\s+/, `ph_resize --scale $opts{th1_size} --dryrun --printres $path /dev/null`);

    # time from exif
    my ($time,$alt,$lat,$lon) = get_exif($path);

    # day only
    my $date = (split(/\s+/, $time))[0] || '';

    # relative path
    my $p = $file; $p=~s|^$opts{basedir}/||; # relative dir

    $files{$file} = {w=>$w, d=>$date, t=>$time, p=>$p};
  }

  rename $opts{infile}, "$opts{infile}.bak" if -f $opts{infile};
  open OUT, "> $opts{infile}" or die "Can't open $opts{infile}: $!\n";

  my $ww=0;  # current width
  my $od=''; # current date

  my @list = $opts{init_tsort}? (sort {$files{$a}->{t} cmp $files{$b}->{t}} keys %files) :
                                (sort keys %files);

  print OUT $opts{init_index_head};
  foreach (@list) {
    my $d = $files{$_}->{d};
    my $w = $files{$_}->{w};
    my $p = $files{$_}->{p};

    if ( $od ne $d && $opts{init_days}){
      print OUT "\n\\h4r $d\n";
      $ww=0;
      $od=$d;
    }

    $ww+=$w;
    if ($ww>$opts{init_width}) {
      print OUT "\n";
      $ww=$w;
    }
    print OUT "\\photo $p\n";
  }

  print OUT $opts{init_index_tail};
  close OUT;
  exit 0 if $opts{init_only};
}




#################################################################
#################################################################
### Read index file, extract photo and header lists, set options.

open IN, $opts{infile} or
  die "can't open $opts{infile}: $!\n";

my @ph;
my @hh;
my @keep;
foreach(<IN>){
  next unless /^\\/; # skip non-command lines
  last if /^\\end/;  # stop at \end command
  if (/$re{photo}/){     # images
    my $al = ($1 eq 'r'?'right':($1 eq 'l'? 'left':'center'));
    my $name = $2;
    my $title = $3 || '';
    if ($name=~m|^/| || $name=~m|^\.\.//| || $name=~m|/\.\./|){
      warn "Skip image with non-relative path: $2\n";
      next;
    }
    push @ph, {files=>[split(',', $name)], title=>$title, align=>$al};
  }
  elsif (/$re{head}/){  # headers
    my ($d, $t) = ($1, $3);
    push @hh, {depth=>$d, title=>$t};
  }
  elsif (/$re{keep}/){  # keep command
    push @keep, $1;
  }
  elsif (/$re{set}/){  # set command
    $opts{$1} = $2;
  }
}


# now all configuration should be read.
my $imgdir = "$opts{basedir}/$opts{imgdir}/";
$imgdir =~ s|^(\./)+||;

#################################################################
#################################################################
# CLEANUP call - remove unused files and exit
if ($opts{cleanup}){
  my %keep;
  print STDERR "[Cleanup mode...]\n" if $opts{verbose};
  foreach my $ph (@ph) {
    my @f = @{$ph->{files}};
    # add all images
    $keep{"$imgdir$_"} = 1 foreach (@f);

    my ($d, $b, $e) = path_split($f[0]);
    # add html and thumbnail for this image
    $keep{"$imgdir$d$b.htm"} = 1;
    $keep{"$imgdir$d$opts{th1_pref}$b$e"} = 1 if $opts{th1_pref};
    $keep{"$imgdir$d$opts{th2_pref}$b$e"} = 1 if $opts{th2_pref};
    $keep{"$imgdir$d$opts{html_pref}$b.htm"} = 1 unless $opts{nohtml};
    # add mark files
    if ( -f "$imgdir$d$b.fig"){
      $keep{"$imgdir$d$b.fig"} = 1;
      $keep{"$imgdir$d$opts{mark_pref}$b.gif"} = 1 if $opts{th1_pref};
    }
  }
  # add files from \keep commands
  foreach my $k (@keep) {
    $keep{$_} = 1 foreach (glob "$imgdir$k");
  }
  # add index file if needed
  $keep{$opts{infile}} = 1 if $opts{imgdir} eq '.';
  $keep{"$opts{basedir}/$opts{html}"} = 1 if $opts{imgdir} eq '.';
  $keep{"${imgdir}addphoto.js"} = 1;
  $keep{"${imgdir}addphoto.css"} = 1;

  ### get files to delete
  my @del;
  foreach(read_dir($imgdir, 1, $imgdir)){
    push(@del, $_) unless exists($keep{$_});
  }
  exit 0 if $#del<0;

  ### print file list
  if (!$opts{quiet}){
    printf STDERR "Files to remove (%d):\n", $#del+1;
    print STDERR join("\n", sort @del), "\n";
  }

  ### ask question
  if (!$opts{force} && !$opts{dryrun}){
    print STDERR "Remove these files (y|N)? ";
    $opts{dryrun} = 1 unless getc =~ /y/i;
  }

  ### remove files
  if (!$opts{dryrun}){
    printf STDERR "%d files have been removed.\n", $#del+1;
    unlink foreach @del;
  }

  exit 0;
}


#################################################################
#################################################################
### Update files, collect information
print STDERR "[Updating files...]\n" if $opts{verbose};
for (my $i=0; $i<@ph; $i++){
  my $ph = $ph[$i];

  $ph->{title}  =~ s/\"/\\\"/g;
  $ph->{atitle} = rem_html($ph->{title});

  my @files = @{$ph->{files}};
  foreach (@files) {die "error: can't find file: $_\n" unless -f "$imgdir$_";}
  my $f0 = shift @files;

  ## previous and next files:
  my $fp = ${$ph[$i==0? $#ph : $i-1]->{files}}[0];
  my $fn = ${$ph[$i==$#ph? 0 : $i+1]->{files}}[0];

  ## navigation links:
  my ($d0, $b0, $e0) = path_split($f0);
  my ($dp, $bp, $ep) = path_split($fp);
  my ($dn, $bn, $en) = path_split($fn);
  my $purl = rel_dir($d0, $dp) . "$bp.htm";
  my $nurl = rel_dir($d0, $dn) . "$bn.htm";
  my $uurl = rel_dir("$opts{imgdir}/$d0", '')  . "$opts{html}#ph" . ($i+1);

  # related files (paths from the image location)
  $ph->{imgname} = "$b0$e0";
  $ph->{figname} = "$b0.fig";
  $ph->{th1name} = "$opts{th1_pref}$b0$e0";
  $ph->{th2name} = "$opts{th2_pref}$b0$e0";
  $ph->{mrkname} = "$opts{mark_pref}$b0.gif";
  $ph->{htmname} = "$opts{html_pref}$b0.htm";

#  my $th1dir = $ph->{th1name} =~
  $ph->{imgdir2img} = $d0;
  $ph->{img2imgdir} = rel_dir($d0, '');

  # related files (paths from cwd)
  $ph->{imgpath} = "$imgdir$d0$ph->{imgname}";
  $ph->{figpath} = "$imgdir$d0$ph->{figname}";
  $ph->{th1path} = "$imgdir$d0$ph->{th1name}";
  $ph->{th2path} = "$imgdir$d0$ph->{th2name}";
  $ph->{mrkpath} = "$imgdir$d0$ph->{mrkname}";
  $ph->{htmpath} = "$imgdir$d0$ph->{htmname}";
  unlink($ph->{htmpath}) if $opts{nohtml};

  ## do we want to create marks?
  $ph->{use_mrk} = -r $ph->{figpath} && $opts{mark_pref};
  $opts{_use_mrk} = 1 if $ph->{use_mrk};

  ############################################################
  ## update thumbnail image:
  $ph->{use_th1} = $opts{th1_pref} && $opts{th1_size};
  if ($ph->{use_th1}) {
    ## if $opts{th1_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{th1_pref}"
      if $opts{th1_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{th1_pref}";
    ## if th1 file is older then the image OR red mark should be cleaned, update th1
    if (isolder($ph->{th1path}, $ph->{imgpath}) ||
        (thmark_check($ph->{th1path}) && ! $ph->{use_mrk} && $#files<0)){
      print STDERR "  updating thumbnail: " if $opts{verbose};
      `ph_resize --scale $opts{th1_size} --verbose $opts{verbose}\\
         --quality $opts{quality} --rm_exif $opts{th1_rm_exif} $ph->{imgpath} $ph->{th1path}`;
    }
    ## add thumbnail mark if needed
    thmark_add($ph->{th1path}) if $ph->{use_mrk} && !thmark_check($ph->{th1path});
    thmark_add($ph->{th1path}) if $#files >= 0;
    ## th1 size
    ($ph->{th1_w}, $ph->{th1_h}) = image_size($ph->{th1path});
  }
  else {
    # th1 size is needed for html index even if file does not exist
     my $ret;
    ($ret, $ph->{th1_w}, $ph->{th1_h}) =
      split /\s+/,`ph_resize --scale $opts{th1_size} --verbose 0 --dryrun $ph->{imgpath} /dev/null`;
  }

  ############################################################
  ## update medium-size thumbnail
  $ph->{use_th2} = $opts{th2_pref} && $opts{th2_size};
  if ($ph->{use_th2}) {
    ## if $opts{th2_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{th2_pref}"
      if $opts{th2_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{th2_pref}";
    ## if th2 file is older then the image, update it
    if (isolder($ph->{th2path}, $ph->{imgpath})){
      print STDERR "  updating medium-size image: " if $opts{verbose};
      `ph_resize --scale $opts{th2_size} --verbose $opts{verbose}\\
         --quality $opts{quality} --rm_exif $opts{th2_rm_exif} $ph->{imgpath} $ph->{th2path}`;
    }
    ## th2 size
    ($ph->{th2_w}, $ph->{th2_h}) = image_size($ph->{th2path});
  }

  ## image size
  ($ph->{img_w}, $ph->{img_h}) = image_size($ph->{imgpath});

  ## exif data
  ($ph->{time}, $ph->{alt}, $ph->{lat}, $ph->{lon}) = get_exif($ph->{imgpath});

  ############################################################
  ## update marks if fig-file exists and newer then the mark file
  if ($ph->{use_mrk}) {
    ## if $opts{mark_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{mark_pref}"
      if $opts{mark_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{mark_pref}";
    ## if th2 file is older then the image, update it
    if (isolder($ph->{mrkpath}, $ph->{figpath})){
      print STDERR "  creating mark file: $ph->{mrkpath}\n" if $opts{verbose};

      my $sc=fig_im_scale($ph->{figpath}, $ph->{imgpath});
      die "Bad fig file: $ph->{figpath}" unless $sc;
      $sc*=2 if $opts{mstyle} ne 'simple_gif';

      ## create gif file
      qx* LANG="$opts{fig_lang}"\\
       fig2dev -m$sc -j -Lgif -D +0:200 -t'#FFFFFF' "$ph->{figpath}" "$ph->{mrkpath}" ||\\
         rm -f -- "$ph->{mrkpath}"*;

      ## build script for convert program
      # IE can only show transparent gifs, not png.
      # We can't use semi-transparent png here :(
      my $cmd;
      if ($opts{mstyle} eq 'simple_gif'){
      }
      elsif ($opts{mstyle} eq 'aa_gif'){
        $cmd=qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 0.8 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite -blur 2 )
            ( "$ph->{mrkpath}" -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
      }
      elsif ($opts{mstyle} eq 'aa_gif_halo'){
        $cmd = qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 1.2 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite )
            ( "$ph->{mrkpath}"
              ( -clone 0 +matte +level-colors white.
                ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
                +matte -compose copy-opacity -composite )
              -compose dst-over -composite
              -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
      }
      elsif ($opts{mstyle} eq 'aa_gif_dark_halo'){
        $cmd = qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 1.2 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite )
            ( "$ph->{mrkpath}" +level 0,30%
              ( -clone 0 +matte +level-colors white
                ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
                +matte -compose copy-opacity -composite )
              -compose dst-over -composite
              -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
       }
#        elsif ($opts{mstyle} eq 'png_dark_halo'){
#        $cmd=qq*
#            "$ph->{mrkpath}" +level 0,30%
#            ( -clone 0 +matte +level-colors white
#              ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
#               +matte -compose copy-opacity -composite )
#            -compose dst-over -composite
#            -resize 50%
#            "$ph->{mrkpath}"*;
#        }

       else{
         die "Unknown mark style: $opts{mstyle}\n";
       }
       if ($cmd){
         $cmd =~ s/([\(\)\n])/\\$1/g;
         qx"convert $cmd";
       }

    }
  }

  ############################################################
  ## Create html page if needed.
  ## We use "key" to check that html-file is up-to-date.

  # image reference for html
  my $imgref = $ph->{use_th2} ? $ph->{th2name}:$ph->{imgname};
  my $w      = $ph->{use_th2} ? $ph->{th2_w}:$ph->{img_w};
  my $h      = $ph->{use_th2} ? $ph->{th2_h}:$ph->{img_h};

  # build new key, extract old one from file
  my ($key, $oldkey) = ('','');
  if (!$opts{nohtml}){
    # make new key
    # all options which affect html pages should be here
    $key = Digest::MD5::md5_hex(join("\n",(
      $imgref, $w, $h, @files,
      $ph->{title}, $purl, $uurl, $nurl,
      ($ph->{use_mrk} ? $opts{mstyle}:''),
      $ph->{use_th1}, $ph->{use_th2},
      $opts{map_ref} || '', $opts{map_zoom},
      $opts{lang} || '',
      $opts{html_charset} || '',
      $opts{html_viewport} || '',
      $opts{html_screen_sw} || '',
      $opts{html_arrows} || '',
      $html_version)));
    # get old key
    if (open KEY, $ph->{htmpath}) {
      while (readline KEY){
        if (m|<!--KEY:([a-fA-F\d]*)-->|){
          $oldkey = $1 if m|<!--KEY:([a-fA-F\d]*)-->|;
          last;
        }
      }
      close KEY;
    }
  }

  if (!$opts{nohtml} && $key ne $oldkey){
    print STDERR "  creating html file: $ph->{htmpath}\n" if $opts{verbose};

    my $scr="";
    my $init="";
    my $top="";
    my $btm="";
    my $head="";
    my $sty="";
    $head .=qq*
      <meta http-equiv="Content-Type" content="text/html; charset=$opts{html_charset}"/>*
      if $opts{html_charset};
    $head .=qq*
      <meta name="viewport" content="width=device-width, initial-scale=1.0">*
        if $opts{html_viewport};
    $head .=qq*
      <link href="$ph->{img2imgdir}addphoto.css" rel="stylesheet"/>*;
    $head .=qq*
      <script type='text/JavaScript' src='$ph->{img2imgdir}addphoto.js'></script>*
      if $opts{lang} || $opts{html_screen_sw} || $ph->{use_mrk} || $opts{html_arrows};

    # make language switch
    if ($opts{lang}){
      $init .= ' onload="lang_init()"';
      $top  .= qq*
        <div align=right>
          <span class="ru_control" id=lang_ru onclick="lang_set('ru')">ru</span>
          <span class="en_control" id=lang_en onclick="lang_set('en')">en</span>
        </div>*;
    }

    # make title
    if ( $ph->{title} ){
      $head .= qq*
      <title>$ph->{atitle}</title>*;
      $btm .= qq*
      <div class=addphoto-title>$ph->{title}</div>*;
    }

    # make navigation panel
    my $nav ='';
    if ( $purl || $uurl || $nurl){
      my $p = get_msg('pref');
      my $u = get_msg('uref');
      my $n = get_msg('nref');
      $p = "<a href=\"$purl\">$p</a>" if $purl;
      $u = "<a href=\"$uurl\">$u</a>" if $uurl;
      $n = "<a href=\"$nurl\">$n</a>" if $nurl;
      $nav .= qq*
      <div class=addphoto-btn>$p</div>
      <div class=addphoto-btn>$u</div>
      <div class=addphoto-btn>$n</div>*;
    }
    # navigation links in the head
    $head .= qq*
    <link rel="top" href="$uurl">* if $uurl;
    $head .= qq*
    <link rel="previous" href="$purl">* if $purl;
    $head .= qq*
    <link rel="next" href="$nurl">* if $nurl;

    $nav .= "\n    <br>";

    # fit-to-screen button
    if ($opts{html_screen_sw}) {
      my $msg = get_msg('sw_size');
      $nav .= qq*
        <div class=addphoto-btn id=addphoto-screen-sw onclick="switch_scr()">$msg</div>*;
      $sty .= qq[
        /* fit-to-screen button */
        #addphoto-screen-sw {display: none;}
        \@media screen and (max-width: ${w}px) {
          #addphoto-screen-sw { display: inline;} }];
    }

    # switch marks button
    if ($ph->{use_mrk}){
      my $msg = get_msg('sw_mark');
      $nav .= qq*
        <div class=addphoto-btn onclick="switch_mrk()">$msg</div>*;
    }
    $top .= qq*
    <div class=addphoto-nav>$nav
    </div>*;

    # main image
    my $main=qq*
      <img id=image class=img1 style='width:${w}px;height:auto;'
           src='$imgref' alt='$ph->{atitle}'>*;

    # marks overlay
    if ($ph->{use_mrk}){
      $main = qq*
      <div style="position: relative;" onclick="switch_mrk();">
        <img id=image class=img1 style='width:${w}px;height:auto;'
             src='$imgref' alt='$ph->{atitle}'>
        <img id=marks class=img1 style='width:${w}px;height:auto;'
             src='$ph->{mrkname}'>
      </div>*;
    }

    # multiple images:
    if ($#files>=0){
      my $nn=$#files+2;
      $scr .= qq*    <script type="text/JavaScript">
        var nv = 0;
        function sw_imgs(){
          nv=(nv+1)\%$nn;
          for (var i=1;i<$nn;i++){
            document.getElementById("img"+i).style.visibility=
              i<=nv?'visible':'hidden'}}
      </script>*;
      $sty .= qq*
        #img0 { position: absolute; left: 0px; top: 0px; width: ${w}px; height: ${h}px; }*;

      $main = qq*
      <div style="position: relative; height: ${h}px;"
           onclick="sw_imgs();">
        <img id="img0" src="$imgref" alt="$ph->{atitle}">*;
      for(my $i=1; $i<=$#files+1; $i++){
        my ($d, $b, $e) = path_split($files[$i-1]);
        $sty .= qq*
          #img$i { position: absolute; left: 0px; top: 0px; width: ${w}px; visibility: hidden; }*;
        $main .= qq*
        <img id="img$i" src="$b$e" alt="$ph->{atitle}">*;
      }
      $main .= qq*
      </div>*;
    }

    # info from exif
    my $exif = '';
    $exif .= "\n      <br/>" . get_msg('dat_fmt') . ' ' . $ph->{time} if $ph->{time};
    $exif .= "\n      <br/>" . get_msg('alt_fmt') . ' ' . $ph->{alt}  if $ph->{alt};
    $exif .= "\n      <br/>" . get_msg('crd_fmt') . ' ' .
       html_crd($ph->{lat}, $ph->{lon}, $ph->{imgname}) if $ph->{lat} && $ph->{lon};

    $btm .= qq*
      <div class=addphoto-info>$exif
      </div>*;

    # full size
    if ($ph->{use_th2}) {
      my $msg = get_msg('fullsize');
      $btm .= qq*
      <div class=addphoto-btn><a href="$b0$e0">[$msg]</a></div>*;
    }

    # wrap style settings
    if ($sty){
      $sty = qq*
      <style type="TEXT/CSS">$sty
      </style>*;
    }

    # write html
    open OUT, "> $ph->{htmpath}" or die "can't open $ph->{htmpath}: $!\n";
    print OUT qq*<html> <!--KEY:$key-->
    <head>$head$scr$sty
    </head>
    <body bgcolor="#FFFFFF"$init>$top$main$btm
    </body>*;
    print OUT "\n</html>\n";
    close OUT;
  }
}

#################################################################
#################################################################
### Write common files: addphoto.js, addphoto.css

open STY, "> ${imgdir}addphoto.css" or die
  "can't open file: ${imgdir}addphoto.css: $!\n";
print STY qq[
/* common decorations */
a {text-decoration:none;}
.img1 {max-width:100%; height:auto;}
.img2 {max-width:''; height:auto;}
.addphoto-nav {
  content:'';
  display:block;
  width:100%;
}
.addphoto-btn {
  color:blue;cursor:pointer;
  font: bold 10pt sans-serif;
  padding:2 10px;
  display:inline-block;
}
.addphoto-title {
  font: 16pt sans-serif;
  margin: 0px; padding-bottom: 20px;
  border-bottom: 1px solid #E0E0E0;
  width: 100%;
}
.addphoto-info {
  font: bold 8pt sans-serif;
}
/* marks layer */
#marks {
  position:absolute;
  left: 0px; top: 0px;
  visibility:visible;
}
/* for index html*/
.addphoto-caption {
  font-style:italic;
  min-height:1.5ex;
  text-align:left;
}
.addphoto-row { content:"";
  display:block;
  margin-left:auto;
  margin-right:auto;
  max-width:100%;
  height:auto;
  text-align:center;
}
.addphoto-img {
  display: inline-block;
  text-align: center;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-th {
  max-width:100%;
  height:auto;
}
];

print STY qq[
/* Language control (see opts{lang}) */
.ru_control,.en_control {color:blue;cursor:pointer; }
.ru {display:inline;}
.en {display:none;}
] if $opts{lang};
close STY;

if (!$opts{nohtml} && (
      $opts{lang} ||
      $opts{html_screen_sw} ||
      $opts{_use_mrk} ||
      $opts{html_arrows} )) {
  open JS, "> ${imgdir}addphoto.js" or die
    "can't open file: ${imgdir}addphoto.js: $!\n";

  print JS qq*
    var langs=['ru', 'en'];
    var lang_def='ru';
    function lang_set(lang){
      document.cookie = "lang=" + lang + "; path=/";
      for (var i=0; i<langs.length; i++){
        document.getElementById("lang_"+langs[i]).style.fontWeight=
          (langs[i]==lang) ? 'bold':'normal';
        var els=document.getElementsByClassName(langs[i]);
        for (var j=0; j<els.length; j++){
          els[j].style.display = (langs[i]==lang) ? 'inline':'none'; }
      }
    }
    // set language from document url
    function lang_init(){
      var cookie = document.cookie;
      var i1 = cookie.indexOf(" lang=");
      if (i1 == -1) { i1 = cookie.indexOf("lang="); }
      if (i1 == -1) {lang_set(lang_def);}
      else {
        i1 = cookie.indexOf("=", i1) + 1;
        var i2 = cookie.indexOf(";", i1);
        if (i2 == -1) { i2 = cookie.length; }
        lang_set(cookie.substring(i1,i2));
      }
    }* if $opts{lang};

  print JS qq*
    function switch_scr(){
      var image = document.getElementById("image");
      if (!image) {return;}
      var cn = (image.className=='img1' ? 'img2':'img1');
      image.className = cn;
      var marks = document.getElementById("marks");
      if (!marks) {return;}
      marks.className = cn;
    }* if $opts{html_screen_sw};

  print JS qq*
    function switch_mrk(){
      var e = document.getElementById("marks");
      if (!marks) {return;}
      e.style.visibility = e.style.visibility=='hidden' ? 'visible':'hidden';
    }* if $opts{_use_mrk};

  print JS qq*
    function process_key(event){
      if (event.code == 'ArrowRight' ||
          event.code == 'ArrowLeft') {
        var links = document.getElementsByTagName("link");
        for (var i = 0; i < links.length; i++) {
          if (event.code == 'ArrowRight' && links[i].rel == "next") {
            window.location.href = links[i].href; }
          if (event.code == 'ArrowLeft' && links[i].rel == "previous") {
            window.location.href = links[i].href; }
        }
      }
    }
    document.addEventListener('keydown', process_key);*
      if $opts{html_arrows};

  close JS;
}

#################################################################
#################################################################
### create index html
seek IN, 0, 0;
my $op_tab=0;
my $np=0;
my $nh=0;

my $of = "$opts{basedir}/$opts{html}";
$of = '/dev/stdout' if $opts{html_stdout};
$of = "| $opts{html_filter} > $of" if $opts{html_filter};

## how to go from html index to image dir:
my $htmldir = "$opts{html}";
$htmldir =~ s/[^\/]*$//;
$htmldir =~ s|/+$||; # remove trailing /
my $htm2image = rel_dir($htmldir, $opts{imgdir});

open OUT, "> $of" or die "Can't open $of: $!\n";
print STDERR "[Creating HTML index: $of]\n" if $opts{verbose};

foreach(<IN>){
  if (/$re{photo}/){ # \photo commands
    my $ph = $ph[$np++];
    my ($img, $title) = (${$ph[$np-1]->{files}}[0], $ph[$np-1]->{title});

    # paths of html page and thumbnail image from album index
    my ($id, $ib, $ie) = path_split($img);
    my $imgfile = "$htm2image$ph->{imgdir2img}$ph->{imgname}";
    my $htmfile = "$htm2image$ph->{imgdir2img}$ph->{htmname}";
    my $th1file = "$htm2image$ph->{imgdir2img}$ph->{th1name}";
    my $th2file = "$htm2image$ph->{imgdir2img}$ph->{th2name}";
    my $mrkfile = "$htm2image$ph->{imgdir2img}$ph->{mrkname}";
    # what to use in the index:
    my $th0file = $ph->{use_th1} ? $th1file : ($ph->{use_th2} ? $th2file : $imgfile);

    # get size of small thumbnail (it can be missing if use_th1==0!)
    unless ($ph->{th1_w} && $ph->{th1_h}) {
      my $ret;
      ($ret, $ph->{th1_w}, $ph->{th1_h}) =
      split(/\s+/, `ph_resize --scale $opts{th1_size} --dryrun --printres $ph->{imgpath} /dev/null`);
    }

    my $pswp_data='';
    if ($opts{pswp}){
      $pswp_data .= " class='pswp_image'";
      $pswp_data .= " data-size=$ph->{th1_w}x$ph->{th1_h}";
    }

    print OUT "<div class=addphoto-row>\n" unless $op_tab;
    $op_tab=1;
    print OUT "<div class=addphoto-img><a name='ph$np'></a>\n";

    # collect all information for pswp in <div>
    if ($opts{pswp}){
      # size of the big image
      print OUT "<div class='pswp_image' data='$imgfile' data-size='$ph->{img_w}x$ph->{img_h}'\n";
      print OUT "  data-med='$th2file' data-med-size='$ph->{th2_w}x$ph->{th2_h}'\n" if $ph->{use_th2};
      print OUT "  mark-src='$mrkfile'\n" if $ph->{use_mrk};

      print  OUT "  dat='$ph->{time}'" if $ph->{time};
      printf OUT "  alt='%.1f'", $ph->{alt} if $ph->{alt};
      printf OUT "  lat='%.6f'", $ph->{lat} if $ph->{lat};
      printf OUT "  lon='%.6f'", $ph->{lon} if $ph->{lon};
      print  OUT ">\n";
      print  OUT "<a href='$imgfile'>\n";
    }
    else {
      print OUT "<a href='$htmfile'>\n";
    }
    print OUT "<img src='$th0file' alt='$ph->{atitle}'\n";
    print OUT "  width=$ph->{th1_w} height=$ph->{th1_h} class=addphoto-th></a><br>\n";
    print OUT "<div class=addphoto-caption style='width:$ph->{th1_w}'>$ph->{title}</div>\n";
    if ($opts{pswp}){ print OUT "</div>\n"; }
    print OUT "</div>\n";
  }
  else{
    print OUT "</div>\n" if $op_tab; # close row
    $op_tab=0;
    if (/$re{head}/){ # \h commands
      $nh++;
      my ($depth, $title) = ($hh[$nh-1]->{depth}, $hh[$nh-1]->{title});
      print OUT ($2 eq 'r'?'<hr>':'') .
        "<a name='h" . $nh . "'></a><h$depth>$title</h$1>\n";
    }
    elsif (/^\\toc/){ html_toc(*OUT, \@hh); }
    elsif (/^\\end/){ last; }
    elsif (/^\\\\/){ s/^\\//; print OUT $_; }
    elsif (/^\\#/){}    # skip comments
    elsif (/^\\keep/){} # skip keep commands
    elsif (/^\\set/){}  # skip set command
    elsif (/^\\/){ warn "warning: skipping unknown command: $_\n"; }
    else{ print OUT $_; }
  }
}
print OUT "</div>\n" if $op_tab; # close row
close OUT;
print STDERR "[Done: $np photos, $nh headers]\n" if $opts{verbose};

__END__

=head1 NAME

addphoto2 -- create html photoalbums from text templates

=head1 SYNOPSIS

$0 <options> <infile>

=head1 OPTIONS

=over 2

=item  h|help           -- print help message

=item  v|verbose:1      -- be verbose

=item  D|imgdir=s       -- image dir (relative to index file location, default .)

=item  H|html=s         -- html file (relative to index file location)

=item  html_filter=s    -- filter for index html

=item  html_stdout:1    -- print index html to stdout instead of writing to file. html option is still needed.


=item  C|cleanup       --  CLEANUP MODE: remove unused files and exit

=item  f|force:1       --  cleanup mode: do not ask before deleting files

=item  th1_pref=s      --  Small thumbnail prefix (can end with /), empty for no thumbnails

=item  th1_size=s      --  Small thumbnail size (S1:S2:S3, see elsewhere)

=item  th1_rm_exif:1   --  Remove exif-data from small thumbnails (default)

=item  th2_pref=s      --  Large thumbnail prefix (can and with /), empty for no thumbnails

=item  th2_size=s      --  Large thumbnail size (S1:S2:S3, see elsewhere)

=item  th2_rm_exif:1   --  Remove exif-data from large thumbnails (default)

=item  mark_pref=s     --  Image marks prefix (can and with /), empty for no marks

=item  html_pref=s     --  Image marks prefix (can and with /), empty for no marks

=item  nohtml:1        --  Do not generate hmtl pages for images

=item  mstyle=s        --  Mark style

=item  l|lang:1        --  Language support

=item  pswp:1          --  PhotoSwipe support

=item  quality=i       --  Jpeg quality for thumbnails (default 90)

=item  map_ref=s       --  Map link style (gmap, nakarte)

=item  map_zoom=i      --  Map link zoom (default 6)

=item  fig_lang=s        --  fig language

=item  fig_res=f         --  fig resolution

=item  html_charset=s    --  add meta charset tag in html pages (not in index html)

=item  html_viewport:1   --  add meta viewport tag in html pages (not in index html)

=item  html_screen_sw:1  --  add "size" switch to html pages.

=item  html_arrows:1     --  add left/right arrow navigation to html pages.

=back

=head1 DESCRIPTION

=head2 Files and directories

=over 2

=item B<Index file.> It contains the album structure: list of images,
text, configuration. Name of index file is taken from an argument
of the program. In init mode (-I,--init option) index file is created
(old one is moved to *.bak if it exists). In other modes the index file
should exist.

=item B<Image folder.> Folder for all album images and other files. It is
specified in I<--imgdir> option as a relative path from location of the
index file. Default value is '.'. Paths of all album images are counted
from this folder.

If a folder name is given to a program instead of index file the
B<Image folder> is set to this name and B<Index file> name is
foremed by adding .txt to this name.

=item B<HTML-file.> File for html code of the album. File is always
overwritten by the program. Specified by I<--html> option as a relative
path counted from location of the index file. Default name is created
from the index file name by removing last extension (if it exists) and
adding '.htm' instead.

=item B<Image files.> In init mode (-I,--init option) program finds and
write into the index file all image files located in the image folder
(default) and in all subfolders (with -r, --recursive option). In the
index file one can use any path to the image, relative to the image
folder.

=item B<Thumbnails.>There are two sizes of thumbnail images.
Names for thumbnail images are made from image names
by adding a prefix which can be set by options --th1_pref (for small thumbnails),
--th2_pref (for large thumbnails). If the prefix ends with '/' then
thumbnails are locates in a subfolder. Sizes of thumbnails are set by
--th1_size and --th2_size options (in W1:W2:W3 format, see elsewhere).

=item B<Marks.>Marks are made from a fig file located near the image
file. Names for a mark image is made from the image name by adding a
prefix which can be set by options --mark_pref. If the prefix ends with
'/' then marks are locates in a subfolder.

=back


=head2 Init mode

Init mode starts if B<-I,--init> or B<-J,--init_only> option is set. In this
mode a new index file is created with all images located in the image
folder. Then the normal mode is started (if the option was --init).
Options:

=over 2

=item  I|init           -- INIT MODE: create index file

=item  J|init_only      -- create index file and exit

=item  T|init_tsort:1   -- init mode: sort photos by time

=item  d|init_days:1    -- init mode: add day headers

=item  r|init_rec:1     -- init mode: find files recursively

=item  w|init_width=i   -- init mode: max page width

=item  init_img_mask=s  -- init mode: mask for finding images

=item  init_index_head=s -- init mode: head for the index file

=item  init_index_tail=s -- init mode: tail for the index file

=back


=head2 Input file syntax:

Commands are started at the beginning of line with '\' symbol.
Other lines copied without changes. Commands:

=over 2

=item \photo  <file> <title>     -- photo

=item \photo[r|l] <file> <title> -- left/right aligned photo

=item \photo  <file1>,<file2>,... <title>     -- multiple photos on a single page

=item \h(1|2|3|4)[r] <title>     -- header, 'r' for ruler above it

=item \toc                       -- table of contents

=item \end                       -- stop processing file

=item \#                         -- comment line

=item \\<any text>               -- put '\' at the beginning of the line.

=item \\set <name> <value>       -- set an option.

=back

Report bugs to <slazav\@altlinux.org>

=cut
