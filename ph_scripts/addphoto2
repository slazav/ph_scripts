#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use Digest::MD5;

#################################################################
### get options 
my %opts = (
  verbose          => 0,
  imgdir           => '.',
  init_img_mask    => '(.jpe?g$)|(.png$)|(.tiff?$)|(.gif)$',
  init_index_head  => "<html><body>\n",
  init_index_tail  => "</body></html>\n",
  init_width       => 800,
  init_tsort       => 1,
  init_days        => 1,
  th1_pref         => '_',
  th1_size         => '260:160:800',
  th1_rm_exif      => 1,
  th2_pref         => '',
  th2_size         => '800:600:1600',
  th2_rm_exif      => 1,
  mark_pref        => '_',
  html_pref         => '',
  quality          => 90,
  map_ref          => 'nakarte',
  map_zoom         => 13,
  fig_lang         => 'ru_RU.KOI8-R',
  html_charset     => 'koi8-r',
  html_viewport    => 1,
  html_screen_sw   => 1,
  html_arrows      => 1,
  html_resize      => 1,
  mstyle           => 'aa_gif',
  fig_res          => 14.2875, # convert pixel -> fig units
  lang             => 'select',
  ruen_q1          => '\`',
  ruen_q2          => '\'',
);
Getopt::Long::Configure("no_ignore_case");
Getopt::Long::GetOptions(
  "h|help"          => \$opts{help},         # print help message
  "v|verbose:1"     => \$opts{verbose},      # be verbose
  "D|imgdir=s"      => \$opts{imgdir},       # image dir (relative to index file location, default .)
  "H|html=s"        => \$opts{html},         # html file (relative to index file location)
  "html_filter=s"   => \$opts{html_filter},  # filter for index html
  "html_stdout:1"   => \$opts{html_stdout},  # print index html to stdout instead of writing to file. html option is still needed.
  "I|init"          => \$opts{init},         # INIT MODE: create index file
  "J|init_only"     => \$opts{init_only},    # create index file and exit
  "T|init_tsort:1"  => \$opts{init_tsort},   # init mode: sort photos by time
  "d|init_days:1"   => \$opts{init_days},    # init mode: add day headers
  "r|init_rec:1"    => \$opts{init_rec},     # init mode: find files recursively
  "w|init_width=i"  => \$opts{init_width},         # init mode: max page width
  "init_img_mask=s" => \$opts{init_img_mask},      # init mode: mask for finding images
  "init_index_head=s"  => \$opts{init_index_head}, # init mode: head for the index file
  "init_index_tail=s"  => \$opts{init_index_tail}, # init mode: tail for the index file
  "dump_opts:1"     => \$opts{dump_opts},    # DUMP options
  "dump_defs:1"     => \$opts{dump_defs},    # DUMP definitions
  "dump_inp:1"      => \$opts{dump_inp},     # DUMP input files
  "C|cleanup"       => \$opts{cleanup},      # CLEANUP MODE: remove unused files and exit
  "f|force:1"       => \$opts{force},        # cleanup mode: do not ask before deleting files
  "dryrun:1"        => \$opts{dryrun},       # cleanup mode: do not delete files
  "th1_pref=s"      => \$opts{th1_pref},     # Small thumbnail prefix (can end with /), empty for no thumbnails
  "th1_size=s"      => \$opts{th1_size},     # Small thumbnail size (S1:S2:S3, see elsewhere)
  "th1_rm_exif:1"   => \$opts{th1_rm_exif},  # Remove exif-data from small thumbnails (default)
  "th2_pref=s"      => \$opts{th2_pref},     # Large thumbnail prefix (can and with /), empty for no thumbnails
  "th2_size=s"      => \$opts{th2_size},     # Large thumbnail size (S1:S2:S3, see elsewhere)
  "th2_rm_exif:1"   => \$opts{th2_rm_exif},  # Remove exif-data from large thumbnails (default)
  "mark_pref=s"     => \$opts{mark_pref},    # Image marks prefix (can and with /), empty for no marks
  "html_pref=s"     => \$opts{html_pref},    # Image marks prefix (can and with /), empty for no marks
  "nohtml:1"        => \$opts{nohtml},       # Do not generate hmtl pages for images
  "mstyle=s"        => \$opts{mstyle},       # Mark style
  "l|lang=s"        => \$opts{lang},         # Language (ru, en, select)
  "pswp:1"          => \$opts{pswp},         # PhotoSwipe support
  "quality=i"       => \$opts{quality},      # Jpeg quality for thumbnails (default 90)
  "map_ref=s"       => \$opts{map_ref},      # Map link style (gmap, nakarte)
  "map_zoom=i"      => \$opts{map_zoom},     # Map link zoom (default 6)
  "fig_lang=s"      => \$opts{fig_lang},     # fig language
  "fig_res=f"       => \$opts{fig_res},      # fig resolution
  "html_charset=s"  => \$opts{html_charset}, # add meta charset tag in html pages (not in index html)
  "html_viewport:1" => \$opts{html_viewport},# add meta viewport tag in html pages (not in index html)
  "html_screen_sw:1"=> \$opts{html_screen_sw}, # add "fit to screen" switch to html pages
  "html_arrows:1"   => \$opts{html_arrows},  # add navigation (including left/right arrows) to html pages
  "html_resize:1"   => \$opts{html_resize},  # resizable images in html pages (default state of "size" button)
) or pod2usage(1);

my $html_version = '2.3'; # changes when regenerating of html pages is needed

pod2usage(-exitval => 0, -verbose => 2) if $opts{help};
pod2usage(1) if @ARGV!=1;

# index file name
$opts{infile} = shift;

# basedir (where infile located)
$opts{basedir} = $opts{infile};
$opts{basedir} =~ s/[^\/]*$//;
$opts{basedir} =~ s|/+$||; # remove trailing /
$opts{basedir} = '.' if $opts{basedir} eq '';

if (-d $opts{infile}){
  $opts{imgdir} = $opts{infile};
  $opts{imgdir} =~ s/.*\///; # remove path
  $opts{infile} .= '.txt';
}

# html file name (relative to index file, can be changed later)
unless ($opts{html}){
  $opts{html} = $opts{infile};
  $opts{html} =~ s/\.[^\.]*$/.htm/;
}

#################################################################
#### FILE AND PATH FUNCTIONS

#################################################################
## list all files in the directory.
sub read_dir{
  my @ret;
  my $dir   = shift;         # base dir
  my $rec   = shift || 0;    # recursive?
  my $retdir  = shift || ''; # inclure dir into return?
  unless(opendir D, $dir){
    warn "Skipping unreadable directory: $dir: $!\n";
    return;
  }
  my @list = readdir D;
  closedir D;

  foreach my $f (@list){
    next if $f =~ /^\.{1,2}$/;
    my $df = "$dir/$f";
    push(@ret, $retdir.$f) if (-f $df);
    push(@ret, read_dir($df,$rec,$retdir.$f.'/')) if -d $df && $rec;
  }
  return @ret;
}

## Do we need to update file1 from file2
## (is it older or does not exist)?
sub isolder($$){
  return 0 if (!-r $_[1]);
  return 1 if (!-r $_[0]);
  return (stat $_[0])[9] < (stat $_[1])[9];
}

## split path into full directory name + basename + last extension
## './some/path/file.e1.e2.ext' -> './some/path/' + 'file.e1.e2' + '.ext'
sub path_split($){
  $_[0]=~m&(.*\/)?((.*)(\..*)|(.*)())&;
  return (($1 or ''), ($3 or $5 or ''), ($4 or $6 or ''));
}

## Get relative path from dir1 to dir2.
## Absolute paths, . and .. are ignored!
sub rel_dir($$){
  my @d1 = grep {/.+/ && !/^\.{1,2}$/} split '/', shift;
  my @d2 = grep {/.+/ && !/^\.{1,2}$/} split '/', shift;
  my $n;
  for ($n = 0; $n <= $#d1 && $n <= $#d2; $n++){
    last if ($d1[$n] ne $d2[$n])
  }
  my $ret='';
  $ret .= "../" foreach @d1[$n..$#d1];
  $ret .= "$_/" foreach @d2[$n..$#d2];
  return $ret;
}

#################################################################
#### IMAGE SIZE FUNCTIONS

## get image size (identify from ImageMagick is needed).
sub image_size($){
  `identify "$_[0]" 2> /dev/null` =~/(\d+)x(\d+)/;
  return ($1 || 0, $2 || 0);
}

## calculate rescaling factor:
# - "Usual" images will be scaled to fit into S1xS1 square;
# - long images will not be smaller then S2 on short edge;
# - very long images will not be larger than S3 on long edge;
# - small images will not be modified.
sub image_scfactor($$$$$){
  my ($x, $y, $m1, $m2, $m3) = @_;
  $x=1.0*$x; $y=1.0*$y;

  my $kx = $x/$m1;
  my $ky = $y/$m1;

  my $k = $kx>$ky ? $kx:$ky;

  $k = $x/$m2 if $x/$k < $m2;
  $k = $y/$m2 if $y/$k < $m2;

  $k = $x/$m3 if $x/$k > $m3;
  $k = $y/$m3 if $y/$k > $m3;

  $k = 1 if $k<=1;
  return $k;
}

## get fig image dimensions in "pixels"
sub fig_im_scale($$){
  my ($figpath, $img) = @_;
  my ($w, $h) = image_size($img);
  $img=~s|.*/||;
  my $fh;
  open $fh, $figpath or return (0,0);
  while (readline $fh){
    next unless (/^\s+\d+\s+$img/);
    readline($fh) =~
      /^\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)/;
    my @x=sort($1, $3, $5, $7);
    my @y=sort($2, $4, $6, $8);


    my $fw = abs($x[3]-$x[1])/$opts{fig_res};
    my $fh = abs($y[3]-$y[1])/$opts{fig_res};
    return ($h/$fh + $w/$fw) / 2;
  }
  return 0;
}

#################################################################
#### HTML writing functions


## create table of contents
sub html_toc($$){
  my $fh = shift;
  my $data = shift;
  my $dp=0; # prev depth
  my $d0=0; # initial depth
  my $nh = 0;
  foreach my $b (@{$data}){
    next unless $b->{type} eq 'head';
    $nh++;
    my ($d, $t) = ($b->{depth}, $b->{title});
    if ($dp==$d0){ $dp=$d0=$d-1; }
    for (;$dp<$d;$dp++) {print $fh '  'x($dp-1) . "<ul>\n";}
    for (;$dp>$d;$dp--) {print $fh '  'x($dp-2) . "</ul>\n";}
    print $fh '  'x($d-1) . "<li><a href=\"#h$nh\">$t</a>\n";
  }
  for (;$dp>$d0;$dp--) {print $fh '  'x($dp-2) . "</ul>\n";}
}

#################################################################
#### EXIF functions

## Get exif-data as a hash, convert some values to human-readable form.
## Returns hash ref with original exif fields and some converted fields:
##  dat -- Exif.Photo.DateTimeOriginal or Exif.Image.DateTime,
##  lon, lat, alt -- coordinates, altitude.
## exiv2 program is needed.
sub get_exif{
  my $file=shift;
  my $exif;
  my $n;
  # parse values from exiv2 output.
  foreach (`exiv2 -Pkv "$file" 2>/dev/null`){
    chomp;
    my ($k, $v) = split(/\s+/,$_,2);
    $exif->{$k}=$v if $v && $k;
  }

  my ($time, $alt, $lat, $lon);
  # DateTime: convert 2009:10:20 10:11:12 -> 2009/10/20 10:11:12
  foreach $n ('Exif.Image.DateTime',
              'Exif.Photo.DateTimeOriginal'){
    if ((exists $exif->{$n}) && ($exif->{$n} =~ /^(\d+):(\d+):(\d+)\s+(\d+):(\d+):(\d+)/)){
      $time = "$1/$2/$3 $4:$5:$6"; }
  }

  # convert alt, lat, lon
  $n='Exif.GPSInfo.GPSAltitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)/)){
    $alt = 1.0*$1/$2;
    # $n.Ref can be 0, 1 (invert altitude), 220/100 (xiaomi phones)
    $alt=-$alt if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'} eq "1");
  }
  $n='Exif.GPSInfo.GPSLatitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)\s+(\d+)\/(\d+)\s+(\d+)\/(\d+)/)){
    $lat = 1.0*$1/$2 + 1.0/60.0*$3/$4 + 1.0/3600.0*$5/$6;
    $lat=-$lat if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}=~/^S/);
  }
  $n='Exif.GPSInfo.GPSLongitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)\s+(\d+)\/(\d+)\s+(\d+)\/(\d+)/)){
    $lon = sprintf "%.7f", 1.0*$1/$2 + 1.0/60.0*$3/$4 + 1.0/3600.0*$5/$6;
    $lon=-$lon if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}=~/^W/);
  }
  return ($time, $alt, $lat, $lon);
}


#################################################################
#### THUMBNAIL MARKS
## Thumbnail images can is marked with red dot if there are
## some marks on the image. The mark is also kept in the jpeg comment
## These two functions can add and check mark. For remothing mark
## just regenerate thumbnail...
## exiv2 and mogrify (from ImageMagick) programs are needed.
sub thmark_add($){
  my $f=shift;
  `mogrify -fill red -draw 'circle 10,10,12,12' "$f"`;
  `exiv2 -c "<marked>" "$f" 2>/dev/null`;
}
sub thmark_check($){
  my $f=shift;
  return -r $f && `exiv2 -pc "$f" 2>/dev/null` =~ /<marked>/;
}

#################################################################
## HTML messages

my %msgs_ru = (
  dat_fmt  => 'Дата и время съемки:',
  alt_fmt  => 'Высота, м:',
  crd_fmt  => 'Координаты:',
  pref     => 'предыдущая (Ctrl-Left)',
  uref     => 'к оглавлению (Esc)',
  nref     => 'следующая (Ctrl-Right)',
  fullsize => 'полный размер',
  sw_size  => 'размер (S или левая кнопка мыши)',
  sw_mark  => 'отметки (M or Enter)',
  sw_imgs  => 'картинки (I)',
  sw_lang  => 'язык (T)',
);

my %msgs_en = (
  dat_fmt  => 'Date and time:',
  alt_fmt  => 'Altitude, m:',
  crd_fmt  => 'Latitude and longitude:',
  pref     => 'previous (Ctrl-Left)',
  uref     => 'up (Esc)',
  nref     => 'next (Ctrl-Right)',
  fullsize => 'full size',
  sw_size  => 'size (S or Left mouse button)',
  sw_mark  => 'marks (M or Enter)',
  sw_imgs  => 'images (I)',
  sw_lang  => 'language (T)',
);

sub get_msg($){
  my $id = shift;
  return "<div class=ru>$msgs_ru{$id}</div><div class=en>$msgs_en{$id}</div>"
    if $opts{lang} eq 'select';
  return $msgs_ru{$id} if $opts{lang} eq 'ru';
  return $msgs_en{$id};
}

## print latlon coords with or without referense to google/nakarte
sub crd_url($$$){
  my ($lat, $lon, $name) = @_;
  my $style = $opts{map_ref};
  my $zoom  = $opts{map_zoom};
  if ($style eq 'gmap'){
    return sprintf('http://maps.google.com?t=h&q=%.7f+%.7f&ll=%.7f,%.7f&z=%d',
                    $lat, $lon, $lat, $lon, $zoom);
  }
  if ($style eq 'nakarte'){
    return sprintf('https://nakarte.me/#m=%d/%f/%f&nktp=%f/%f/%s&l=O',
                    $zoom, $lat, $lon, $lat, $lon, $name);
  }
  return '';
}

## print latlon coords with or without referense to google/nakarte
sub html_crd($$$){
  my ($lat, $lon, $name) = @_;
  my $url = crd_url($lat, $lon, $name);
  if ($url) {return sprintf('<a href="%s">%.7f %.7f</a><br/>',$url, $lat, $lon);}
  return sprintf('%.7f %.7f', $lat, $lon);
}

#################################################################
#################################################################
# INIT call - do index file, then continue as usual
if ($opts{init} || $opts{init_only}){

  print STDERR "[Creating index file...]\n" if $opts{verbose};
  die "can't find base folder: $opts{basedir}\n"
    unless -d $opts{basedir};

  die "can't find image folder: $opts{basedir}/$opts{imgdir}\n"
    unless -d "$opts{basedir}/$opts{imgdir}";

  ## get image file list
  my @files = grep {/$opts{init_img_mask}/i}
    read_dir("$opts{basedir}/$opts{imgdir}", $opts{init_rec});

  ## remove thumbnail, mark, html files from the list
  @files = grep {!/^$opts{th1_pref}.+$opts{init_img_mask}|\/$opts{th1_pref}.+$opts{init_img_mask}/i} @files
    if $opts{th1_pref};
  @files = grep {!/^$opts{th2_pref}.+$opts{init_img_mask}|\/$opts{th2_pref}.+$opts{init_img_mask}/i} @files
    if $opts{th2_pref};
  @files = grep {!/^$opts{mark_pref}.+$opts{init_img_mask}|\/$opts{mark_pref}.+$opts{init_img_mask}/i} @files
    if $opts{mark_pref};

  ## collect information about files: date, time, thumbnail width
  my %files;
  foreach my $file (@files) {
    my $path = "$opts{basedir}/$opts{imgdir}/$file";

    # get width of small thumbnail (it can be missing!)
    my ($ret, $w, $h) =
      split(/\s+/, `ph_resize --scale "$opts{th1_size}" --dryrun --printres "$path" /dev/null`);

    # time from exif
    my ($time,$alt,$lat,$lon) = get_exif($path);

    # day only
    my $date = (split(/\s+/, $time))[0] || '';

    # relative path
    my $p = $file; $p=~s|^$opts{basedir}/||; # relative dir

    $files{$file} = {w=>$w, d=>$date, t=>$time, p=>$p};
  }

  rename $opts{infile}, "$opts{infile}.bak" if -f $opts{infile};
  open OUT, "> $opts{infile}" or die "Can't open $opts{infile}: $!\n";

  my $ww=0;  # current width
  my $od=''; # current date

  my @list = (sort keys %files);
  @list = sort {$files{$a}->{t} cmp $files{$b}->{t}} @list if $opts{init_tsort};

  print OUT "\\set imgdir $opts{imgdir}\n" if $opts{imgdir} ne '.';
  print OUT $opts{init_index_head};
  foreach (@list) {
    my $d = $files{$_}->{d};
    my $w = $files{$_}->{w};
    my $p = $files{$_}->{p};

    if ( $od ne $d && $opts{init_days}){
      print OUT "\n\\h4r $d\n";
      $ww=0;
      $od=$d;
    }

    $ww+=$w;
    if ($ww>$opts{init_width}) {
      print OUT "\n";
      $ww=$w;
    }
    print OUT "\\photo $p\n";
  }

  print OUT $opts{init_index_tail};
  close OUT;
  exit 0 if $opts{init_only};
}




#################################################################
#################################################################
### Read index file, extract photo and header lists, set options.


sub read_file($$$$);

# read input file
sub read_file($$$$){
  my $fname = shift;
  my $data  = shift;
  my $defs  = shift;
  my $opts  = shift;
  open IN, $fname or
    die "can't open $fname: $!\n";

  my $buf = '';
  foreach(<IN>){

    #joining lines
    if (/(.*)\\$/) { $buf .= $1; next; }
    if ($buf){
      $_ = $buf . $_;
      $buf = '';
    }

    last if /^\\end/;  # stop at \end command
    next if /^\\#/;    # skip comments

    foreach my $k (keys %{$defs}){
      s/\$\{$k\}/$defs->{$k}/g;
    }

    if (/^\\photo([lr]?)\s+(\S+)\s*(.*)/){     # images
      my $al = ($1 eq 'r'?'right':($1 eq 'l'? 'left':'center'));
      my $name = $2;
      my $title = $3 || '';
      if ($name=~m|^/| || $name=~m|^\.\.//| || $name=~m|/\.\./|){
        warn "Skip image with non-relative path: $2\n";
        next;
      }
      my @files = split(',', $name);
      push @{$data}, {type=>'photo', files=>[@files], title=>$title, align=>$al};
      next;
    }

    if (/^\\h([1-4])(r?)\s+(.*)/){  # headers
      push @{$data}, {type=>'head', depth=>$1, ruler=>($2 eq 'r'), title=>$3};
      next;
    }

    if (/^\\toc/){  # toc command
      push @{$data}, {type=>'toc'};
      next;
    }

    if (/^\\keep\s+(.*)/){  # keep command
      push @{$data}, {type=>'keep', globs=>[split('\s+', $1)]};
      next;
    }

    if (/^\\set\s+(\S+)\s+(.*)/){  # set command
      $opts->{$1} = $2;
      next;
    }

    if (/^\\def\s+(\S+)\s+(.*)/){  # def command
      $defs->{$1} = $2;
      next;
    }

    if (/^\\ifdef\s+(\S+)\s+(.*)/){  # ifdef command
      if (exists $defs->{$1}){ $_="$2\n"; }
      else { next; }
    }

    if (/^\\ifndef\s+(\S+)\s+(.*)/){  # ifndef command
      unless (exists $defs->{$1}){ $_="$2\n"; }
      else { next; }
    }

    if (/^\\ifeq\s+(\S+)\s+(\S+)\s+(.*)/){  # ifndef command
      if ($1 eq $2){ $_="$3\n"; }
      else { next; }
    }

    if (/^\\ifneq\s+(\S+)\s+(\S+)\s+(.*)/){  # ifndef command
      if ($1 ne $2){ $_="$3\n"; }
      else { next; }
    }

    if (/^\\inc\s+(\S+)/){  # inc command
      read_file($1, $data, $defs, $opts);
      next;
    }

    if (/^\\[^\\]/){
      warn "warning: skipping unknown command: $_\n";
      next;
    }

    s/^\\// if /^\\\\/; # remove quoted '\'

    # add/append text block
    if ($#{$data}>0 && $data->[$#{$data}]->{type} eq 'text') {
      $data->[$#{$data}]->{text} .= $_;
    }
    else {
      push @{$data}, {type=>'text', text=>$_};
    }
  }
}

my %defs;
my @data;
read_file($opts{infile}, \@data, \%defs, \%opts);

# make separate array of photos
my @ph;
foreach my $b (@data){
  push @ph, $b if $b->{type} eq 'photo';
}

# now all configuration should be read.
my $imgdir = "$opts{basedir}/$opts{imgdir}/";
$imgdir =~ s|^(\./)+||;

#################################################################
#################################################################
# DUMP call - dump options, defs, parsed file and exit
if ($opts{dump_opts}){
  foreach my $k (keys %opts){
    my $v = defined $opts{$k}? $opts{$k}: "undef";
    print "$k: $v\n";
  }
  exit 0;
}

if ($opts{dump_defs}){
  foreach my $k (keys %defs){
    my $v = defined $defs{$k}? $defs{$k}: "undef";
    print "$k: $v\n";
  }
  exit 0;
}

if ($opts{dump_inp}){
  foreach my $b (@data){
    print "\\$b->{type}\n";
    if ($b->{type} eq 'photo') {
      print "  file: $_\n" foreach @{$b->{files}};
      print "  title: $b->{title}\n";
      print "  align: $b->{align}\n";
      next;
    }
    if ($b->{type} eq 'head') {
      print "  title: $b->{title}\n";
      print "  depth: $b->{depth})\n";
      next;
    }
    if ($b->{type} eq 'keep') {
      print "  globs: $_\n" foreach @{$b->{globs}};
      next;
    }
    if ($b->{type} eq 'text') {
      print "  length: ", length($b->{text}), "\n";
      next;
    }
  }
  exit 0;
}
exit 0 if $opts{dump_opts} or $opts{dump_inp};


#################################################################
#################################################################
# CLEANUP call - remove unused files and exit
if ($opts{cleanup}){
  my %keep;
  print STDERR "[Cleanup mode...]\n" if $opts{verbose};
  foreach my $b (@data) {
    if ($b->{type} eq 'photo'){
      my @f = @{$b->{files}};
      # add all images
      $keep{"$imgdir$_"} = 1 foreach (@f);

      my ($d, $b, $e) = path_split($f[0]);
      # add html and thumbnail for this image
      $keep{"$imgdir$d$b.htm"} = 1;
      $keep{"$imgdir$d$opts{th1_pref}$b$e"} = 1 if $opts{th1_pref};
      $keep{"$imgdir$d$opts{th2_pref}$b$e"} = 1 if $opts{th2_pref};
      $keep{"$imgdir$d$opts{html_pref}$b.htm"} = 1 unless $opts{nohtml};
      # add mark files
      if ( -f "$imgdir$d$b.fig"){
        $keep{"$imgdir$d$b.fig"} = 1;
        $keep{"$imgdir$d$opts{mark_pref}$b.gif"} = 1 if $opts{th1_pref};
      }
      next;
    }

    # add files from \keep commands
    if ($b->{type} eq 'keep'){
      foreach my $k (@{$b->{globs}}) {
        $keep{$_} = 1 foreach (glob "$imgdir$k");
      }
      next;
    }
  }

  # add index file if needed
  $keep{$opts{infile}} = 1 if $opts{imgdir} eq '.';
  $keep{"$opts{basedir}/$opts{html}"} = 1 if $opts{imgdir} eq '.';
  $keep{"${imgdir}addphoto.js"} = 1;
  $keep{"${imgdir}addphoto.css"} = 1;

  ### get files to delete
  my @del;
  foreach(read_dir($imgdir, 1, $imgdir)){
    push(@del, $_) unless exists($keep{$_});
  }
  exit 0 if $#del<0;

  ### print file list
  if (!$opts{quiet}){
    printf STDERR "Files to remove (%d):\n", $#del+1;
    print STDERR join("\n", sort @del), "\n";
  }

  ### ask question
  if (!$opts{force} && !$opts{dryrun}){
    print STDERR "Remove these files (y|N)? ";
    $opts{dryrun} = 1 unless getc =~ /y/i;
  }

  ### remove files
  if (!$opts{dryrun}){
    printf STDERR "%d files have been removed.\n", $#del+1;
    unlink foreach @del;
  }

  exit 0;
}


#################################################################
#################################################################
### Update files, collect information
print STDERR "[Updating files...]\n" if $opts{verbose};
for (my $i=0; $i<@ph; $i++){
  my $ph = $ph[$i];
  my $q1=$opts{ruen_q1};
  my $q2=$opts{ruen_q2};

  # remove html tags from text, for html alt atribute
  $ph->{atitle} = $ph->{title};
  $ph->{atitle}=~s|RUEN\(\s*$q1(.*)$q2\s*,\s*$q1.*$q2\)|$1|g;
  $ph->{atitle}=~s/<[^>]*>//g;
  $ph->{atitle}=~s/[<>\']//g; #`

  $ph->{title}=~s|RUEN\(\s*$q1(.*)$q2\s*,\s*$q1(.*)$q2\)|<span class=ru>$1</span><span class=en>$2</span>|g;

  my @files = @{$ph->{files}};
  foreach (@files) {die "error: can't find file: $_\n" unless -f "$imgdir$_";}
  my $f0 = shift @files;

  ## previous and next files:
  my $fp = ${$ph[$i==0? $#ph : $i-1]->{files}}[0];
  my $fn = ${$ph[$i==$#ph? 0 : $i+1]->{files}}[0];

  ## navigation links:
  my ($d0, $b0, $e0) = path_split($f0);
  my ($dp, $bp, $ep) = path_split($fp);
  my ($dn, $bn, $en) = path_split($fn);
  my $purl = rel_dir($d0, $dp) . "$bp.htm";
  my $nurl = rel_dir($d0, $dn) . "$bn.htm";
  my $uurl = rel_dir("$opts{imgdir}/$d0", '')  . "$opts{html}#ph" . ($i+1);

  # files (paths from the image location)
  $ph->{imgname} = "$b0$e0";
  $ph->{figname} = "$b0.fig";
  $ph->{th1name} = "$opts{th1_pref}$b0$e0";
  $ph->{th2name} = "$opts{th2_pref}$b0$e0";
  $ph->{mrkname} = "$opts{mark_pref}$b0.gif";
  $ph->{htmname} = "$opts{html_pref}$b0.htm";

  $ph->{imgdir2img} = $d0;
  $ph->{img2imgdir} = rel_dir($d0, '');

  # paths from cwd
  $ph->{imgpath} = "$imgdir$d0$ph->{imgname}";
  $ph->{figpath} = "$imgdir$d0$ph->{figname}";
  $ph->{th1path} = "$imgdir$d0$ph->{th1name}";
  $ph->{th2path} = "$imgdir$d0$ph->{th2name}";
  $ph->{mrkpath} = "$imgdir$d0$ph->{mrkname}";
  $ph->{htmpath} = "$imgdir$d0$ph->{htmname}";
  unlink($ph->{htmpath}) if $opts{nohtml};

  ## do we want to create marks?
  $ph->{use_mrk} = -r $ph->{figpath} && $opts{mark_pref};
  $opts{_use_mrk} = 1 if $ph->{use_mrk};

  ############################################################
  ## update thumbnail image:
  $ph->{use_th1} = $opts{th1_pref} && $opts{th1_size};
  if ($ph->{use_th1}) {
    ## if $opts{th1_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{th1_pref}"
      if $opts{th1_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{th1_pref}";
    ## if th1 file is older then the image OR red mark should be cleaned, update th1
    if (isolder($ph->{th1path}, $ph->{imgpath}) ||
        (thmark_check($ph->{th1path}) && ! $ph->{use_mrk} && $#files<0)){
      print STDERR "  updating thumbnail: " if $opts{verbose};
      `ph_resize --scale "$opts{th1_size}" --verbose "$opts{verbose}"\\
         --quality "$opts{quality}" --rm_exif "$opts{th1_rm_exif}" "$ph->{imgpath}" "$ph->{th1path}"`;
    }
    ## add thumbnail mark if needed
    thmark_add($ph->{th1path}) if $ph->{use_mrk} && !thmark_check($ph->{th1path});
    thmark_add($ph->{th1path}) if $#files >= 0;
    ## th1 size
    ($ph->{th1_w}, $ph->{th1_h}) = image_size($ph->{th1path});
  }
  else {
    # th1 size is needed for html index even if file does not exist
     my $ret;
    ($ret, $ph->{th1_w}, $ph->{th1_h}) =
      split /\s+/,`ph_resize --scale "$opts{th1_size}" --verbose 0 --dryrun "$ph->{imgpath}" /dev/null`;
  }

  ############################################################
  ## update medium-size thumbnail
  $ph->{use_th2} = $opts{th2_pref} && $opts{th2_size};
  if ($ph->{use_th2}) {
    ## if $opts{th2_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{th2_pref}"
      if $opts{th2_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{th2_pref}";
    ## if th2 file is older then the image, update it
    if (isolder($ph->{th2path}, $ph->{imgpath})){
      print STDERR "  updating medium-size image: " if $opts{verbose};
      `ph_resize --scale "$opts{th2_size}" --verbose "$opts{verbose}"\\
         --quality "$opts{quality}" --rm_exif "$opts{th2_rm_exif}" "$ph->{imgpath}" "$ph->{th2path}"`;
    }
    ## th2 size
    ($ph->{th2_w}, $ph->{th2_h}) = image_size($ph->{th2path});
  }

  ## image size
  ($ph->{img_w}, $ph->{img_h}) = image_size($ph->{imgpath});

  ## exif data
  ($ph->{time}, $ph->{alt}, $ph->{lat}, $ph->{lon}) = get_exif($ph->{imgpath});

  ############################################################
  ## update marks if fig-file exists and newer then the mark file
  if ($ph->{use_mrk}) {
    ## if $opts{mark_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{mark_pref}"
      if $opts{mark_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{mark_pref}";
    ## if th2 file is older then the image, update it
    if (isolder($ph->{mrkpath}, $ph->{figpath})){
      print STDERR "  creating mark file: $ph->{mrkpath}\n" if $opts{verbose};

      my $sc=fig_im_scale($ph->{figpath}, $ph->{imgpath});
      die "Bad fig file: $ph->{figpath}\n" unless $sc;
      $sc*=2 if $opts{mstyle} ne 'simple_gif';

      ## create gif file
      qx* LANG="$opts{fig_lang}"\\
       fig2dev -m$sc -j -Lgif -D +0:200 -t'#FFFFFF' "$ph->{figpath}" "$ph->{mrkpath}" ||\\
         rm -f -- "$ph->{mrkpath}"*;

      ## build script for convert program
      # IE can only show transparent gifs, not png.
      # We can't use semi-transparent png here :(
      my $cmd;
      if ($opts{mstyle} eq 'simple_gif'){
      }
      elsif ($opts{mstyle} eq 'aa_gif'){
        $cmd=qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 0.8 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite -blur 2 )
            ( "$ph->{mrkpath}" -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
      }
      elsif ($opts{mstyle} eq 'aa_gif_halo'){
        $cmd = qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 1.2 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite )
            ( "$ph->{mrkpath}"
              ( -clone 0 +matte +level-colors white.
                ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
                +matte -compose copy-opacity -composite )
              -compose dst-over -composite
              -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
      }
      elsif ($opts{mstyle} eq 'aa_gif_dark_halo'){
        $cmd = qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 1.2 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite )
            ( "$ph->{mrkpath}" +level 0,30%
              ( -clone 0 +matte +level-colors white
                ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
                +matte -compose copy-opacity -composite )
              -compose dst-over -composite
              -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
       }
#        elsif ($opts{mstyle} eq 'png_dark_halo'){
#        $cmd=qq*
#            "$ph->{mrkpath}" +level 0,30%
#            ( -clone 0 +matte +level-colors white
#              ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
#               +matte -compose copy-opacity -composite )
#            -compose dst-over -composite
#            -resize 50%
#            "$ph->{mrkpath}"*;
#        }

       else{
         die "Unknown mark style: $opts{mstyle}\n";
       }
       if ($cmd){
         $cmd =~ s/([\(\)\n])/\\$1/g;
         qx"convert $cmd";
       }

    }
  }

  ############################################################
  ## Create html page if needed.
  ## We use "key" to check that html-file is up-to-date.

  # image reference for html
  my $imgref = $ph->{use_th2} ? $ph->{th2name}:$ph->{imgname};
  my $w      = $ph->{use_th2} ? $ph->{th2_w}:$ph->{img_w};
  my $h      = $ph->{use_th2} ? $ph->{th2_h}:$ph->{img_h};

  # build new key, extract old one from file
  my ($key, $oldkey) = ('','');
  if (!$opts{nohtml}){
    # make new key
    # all options which affect html pages should be here
    $key = Digest::MD5::md5_hex(join("\n",(
      $imgref, $w, $h, @files,
      $ph->{title}, $purl, $uurl, $nurl,
      ($ph->{use_mrk} ? $opts{mstyle}:''),
      $ph->{use_th1}, $ph->{use_th2},
      $opts{map_ref} || '', $opts{map_zoom},
      $opts{lang} || '',
      $opts{html_charset} || '',
      $opts{html_viewport} || '',
      $opts{html_screen_sw} || '',
      $opts{html_arrows} || '',
      $opts{html_resize} || '',
      $html_version)));
    # get old key
    if (open KEY, $ph->{htmpath}) {
      while (readline KEY){
        if (m|<!--KEY:([a-fA-F\d]*)-->|){
          $oldkey = $1 if m|<!--KEY:([a-fA-F\d]*)-->|;
          last;
        }
      }
      close KEY;
    }
  }

  if (!$opts{nohtml} && $key ne $oldkey){
    print STDERR "  creating html file: $ph->{htmpath}\n" if $opts{verbose};

    my $scr="";
    my $init="";
    my $top="";
    my $btm="";
    my $head="";
    my $sty="";
    $head .=qq*
      <meta http-equiv="Content-Type" content="text/html; charset=$opts{html_charset}"/>*
      if $opts{html_charset};
    $head .=qq*
      <meta name="viewport" content="width=device-width, initial-scale=1.0">*
        if $opts{html_viewport};
    $head .=qq*
      <link href="$ph->{img2imgdir}addphoto.css" rel="stylesheet"/>*;
    $head .=qq*
      <script type='text/JavaScript' src='$ph->{img2imgdir}addphoto.js'></script>*
      if $opts{lang} eq 'select' || $opts{html_screen_sw} || $ph->{use_mrk} || $opts{html_arrows};

    # make language switch
    if ($opts{lang} eq 'select'){
      $init .= ' onload="lang_init()"';
      $top  .= qq*
        <div align=right>
          <span class="ru_control" id=lang_ru onclick="lang_set('ru')">ru</span>
          <span class="en_control" id=lang_en onclick="lang_set('en')">en</span>
        </div>*;
    }

    # make title
    if ( $ph->{title} ){
      $head .= qq*
      <title>$ph->{atitle}</title>*;
      $btm .= qq*
      <div class=addphoto-title>$ph->{title}</div>*;
    }

    # make navigation panel
    my $nav ='';
    if ( $purl || $uurl || $nurl){
      my $p = get_msg('pref');
      my $u = get_msg('uref');
      my $n = get_msg('nref');
      $p = "<a href=\"$purl\">$p</a>" if $purl;
      $u = "<a href=\"$uurl\">$u</a>" if $uurl;
      $n = "<a href=\"$nurl\">$n</a>" if $nurl;
      $nav .= qq*
      <div class=addphoto-btn>$p</div>
      <div class=addphoto-btn>$u</div>
      <div class=addphoto-btn>$n</div>*;
    }
    # navigation links in the head
    $head .= qq*
    <link rel="top" href="$uurl">* if $uurl;
    $head .= qq*
    <link rel="previous" href="$purl">* if $purl;
    $head .= qq*
    <link rel="next" href="$nurl">* if $nurl;

    # switch language button
#    if ($opts{lang} eq 'select'){
#      my $msg = get_msg('sw_lang');
#      $nav .= qq*
#        <div class=addphoto-btn onclick="lang_sw()">$msg</div>*;
#    }

    $nav .= "\n    <br>";

    # fit-to-screen button
    if ($opts{html_screen_sw}) {
      my $msg = get_msg('sw_size');
      $nav .= qq*
        <div class=addphoto-btn id=addphoto-screen-sw onclick="switch_scr()">$msg</div>*;
      $sty .= qq[
        /* fit-to-screen button */
        #addphoto-screen-sw {display: none;}
        \@media screen and (max-width: ${w}px) {
          #addphoto-screen-sw { display: inline;} }];
    }

    # switch images button
    if ($#files>=0){
      my $msg = get_msg('sw_imgs');
      $nav .= qq*
        <div class=addphoto-btn onclick="sw_imgs()">$msg</div>*;
    }

    # switch marks button
    if ($ph->{use_mrk}){
      my $msg = get_msg('sw_mark');
      $nav .= qq*
        <div class=addphoto-btn onclick="switch_mrk()">$msg</div>*;
    }


    $top .= qq*
    <div class=addphoto-nav>$nav
    </div>*;

    # image class: img1 will fit to screen, img2 will be of original size
    my $img_class = $opts{html_resize} ? 'img1':'img2';

    # main image
    my $main=qq*
      <img id=img0 class=$img_class style='width:${w}px;height:auto;'
           src='$imgref' alt='$ph->{atitle}' onclick='on_click(event)'>*;

    # marks overlay
    if ($ph->{use_mrk}){
      $main = qq*
      <div style="position: relative;" onclick='on_click(event)'>
        <img id=img0 class=$img_class style='width:${w}px;height:auto;'
             src='$imgref' alt='$ph->{atitle}'>
        <img id=marks class=$img_class style='width:${w}px;height:auto;'
             src='$ph->{mrkname}'>
      </div>*;
    }

    # multiple images:
    if ($#files>=0){
      my $nn=$#files+2;
      $scr .= qq*    <script type="text/JavaScript">
        var nv = 0;
        function sw_imgs(){
          nv=(nv+1)\%$nn;
          for (var i=1;i<$nn;i++){
            document.getElementById("img"+i).style.visibility=
              i<=nv?'visible':'hidden'}}
        function sw_imgs_key(event){
          if (event.code == 'KeyI'){ sw_imgs(); }}
        document.addEventListener('keydown', sw_imgs_key);
      </script>*;
      $main = qq*
      <div style="position: relative;" onclick='on_click(event)'>
         <img id=img0 class=$img_class style='width:${w}px;height:auto;'
              src='$imgref' alt='$ph->{atitle}'>*;
      for(my $i=1; $i<=$#files+1; $i++){
        $sty .= qq*
           #img$i { position: absolute; left: 0px; top: 0px; visibility: hidden; }*;
        my ($d, $b, $e) = path_split($files[$i-1]);
        $main .= qq*
          <img id="img$i" class=$img_class style='width:${w}px;height:auto;'
             src='$b$e'>*;
      }
      $main .= qq*
      </div>*;
    }

    # info from exif
    my $exif = '';
    $exif .= "\n      <br/>" . get_msg('dat_fmt') . ' ' . $ph->{time} if $ph->{time};
    $exif .= "\n      <br/>" . get_msg('alt_fmt') . ' ' . $ph->{alt}  if $ph->{alt};
    $exif .= "\n      <br/>" . get_msg('crd_fmt') . ' ' .
       html_crd($ph->{lat}, $ph->{lon}, $ph->{imgname}) if $ph->{lat} && $ph->{lon};

    $btm .= qq*
      <div class=addphoto-info>$exif
      </div>*;

    # full size
    if ($ph->{use_th2}) {
      my $msg = get_msg('fullsize');
      $btm .= qq*
      <div class=addphoto-btn><a href="$b0$e0">[$msg]</a></div>*;
    }

    # wrap style settings
    if ($sty){
      $sty = qq*
      <style type="TEXT/CSS">$sty
      </style>*;
    }

    # write html
    open OUT, "> $ph->{htmpath}" or die "can't open $ph->{htmpath}: $!\n";
    print OUT qq*<html> <!--KEY:$key-->
    <head>$head$scr$sty
    </head>
    <body bgcolor="#FFFFFF"$init>$top$main$btm
    </body>*;
    print OUT "\n</html>\n";
    close OUT;
  }
}

#################################################################
#################################################################
### Write common files: addphoto.js, addphoto.css

open STY, "> ${imgdir}addphoto.css" or die
  "can't open file: ${imgdir}addphoto.css: $!\n";
print STY qq[
/* common decorations */
a {text-decoration:none;}
.img1 {max-width:100%; height:auto;}
.img2 {max-width:''; height:auto;}
.addphoto-nav {
  content:'';
  display:block;
  width:100%;
}
.addphoto-btn {
  color:blue;cursor:pointer;
  font: bold 10pt sans-serif;
  padding:2 10px;
  display:inline-block;
}
.addphoto-title {
  font: 16pt sans-serif;
  margin: 0px; padding-bottom: 20px;
  border-bottom: 1px solid #E0E0E0;
  width: 100%;
}
.addphoto-info {
  font: bold 8pt sans-serif;
}
/* marks layer */
#marks {
  position:absolute;
  left: 0px; top: 0px;
  visibility:visible;
}
/* for index html*/
.addphoto-caption {
  font-style:italic;
  min-height:1.5ex;
  text-align:left;
}
.addphoto-row {
  content:"";
  display:block;
  margin-left:auto;
  margin-right:auto;
  max-width:100%;
  height:auto;
  text-align:center;
}
.addphoto-img-center {
  display: inline-block;
  vertical-align: top;
  text-align: center;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-img-left {
  display: inline-block;
  float: left;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-img-right {
  display: inline-block;
  float: right;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-th {
  max-width:100%;
  height:auto;
}
];

print STY qq[
/* Language control (see opts{lang}) */
.ru_control,.en_control {color:blue;cursor:pointer; }
.ru {display:inline;}
.en {display:none;}
] if $opts{lang};
close STY;

if (!$opts{nohtml} && (
      $opts{lang} eq 'select' ||
      $opts{html_screen_sw} ||
      $opts{_use_mrk} ||
      $opts{html_arrows} )) {
  open JS, "> ${imgdir}addphoto.js" or die
    "can't open file: ${imgdir}addphoto.js: $!\n";

  print JS qq*
    var langs=['ru', 'en'];
    // get default language
    function lang_def(){
      lvars = [window.navigator.languages, window.navigator.language, window.navigator.userLanguage]
      hasru = false;
      for (const v of lvars) { hasru ||= v && v.includes("ru"); }
      return hasru ? 'ru':'en';
    }
    // save language to storage/cookies
    function lang_save(v){
      // use storage
      if (typeof(Storage) !== "undefined") {
        localStorage.setItem("lang", v);
      }
    }
    // load language from storage/cookies
    function lang_load(){
      if (typeof(Storage) !== "undefined") {
        v = localStorage.getItem("lang");
        return v? v: lang_def();
      } else {
        return lang_def();
      }
    }
    // set language from button
    function lang_set(lang){
      lang_save(lang);
      for (var i=0; i<langs.length; i++){
        document.getElementById("lang_"+langs[i]).style.fontWeight=
          (langs[i]==lang) ? 'bold':'normal';
        var els=document.getElementsByClassName(langs[i]);
        for (var j=0; j<els.length; j++){
          els[j].style.display = (langs[i]==lang) ? 'inline':'none'; }
      }
    }
    // set language after loading document
    function lang_init(){
      var urlParams = new URLSearchParams(window.location.search);
      var l = urlParams.get('lang');
      if (l==null) l=lang_load()
      lang_set(l);
    }
    // switch language
    function lang_sw(){
      lang_set(lang_load()=='ru'? 'en':'ru');
    }
    // switch language with 't' key
    function lang_key(event){
      if (event.code == 'KeyT'){lang_sw();}
    }
    document.addEventListener('keydown', lang_key);* if $opts{lang} eq 'select';

  print JS qq*
    // switch image zoom
    function switch_scr(){
      // note that result of getElementsByClassName is HTMLcollection!
      let i1 = Array.from(document.getElementsByClassName("img1"));
      let i2 = Array.from(document.getElementsByClassName("img2"));
      for (img of i1){ img.className = 'img2'; }
      for (img of i2){ img.className = 'img1'; }
    }* if $opts{html_screen_sw};

  print JS qq*
    // switch image marks
    function switch_mrk(){
      var e = document.getElementById("marks");
      if (!marks) {return;}
      e.style.visibility = e.style.visibility=='hidden' ? 'visible':'hidden';
    }* if $opts{_use_mrk};

  print JS qq*
    // key navigation
    function process_key(event){

      var rel = "";
      if (event.ctrlKey && event.code == 'ArrowRight'){
        rel = "next";
      }
      else if (event.ctrlKey && event.code == 'ArrowLeft'){
        rel = "previous";
      }
      else if (event.code == 'Escape'){
        rel = "top";
      }
      else if (event.code == 'Enter'){
        switch_mrk();
      }
      else if (event.code == 'KeyM'){
        switch_mrk();
      }
      else if (event.code == 'KeyS'){
        switch_scr();
      }

      if (rel == "") return;

      var links = document.getElementsByTagName("link");
      for (var i = 0; i < links.length; i++) {
        if (links[i].rel != rel) continue;
        event.preventDefault();
        event.stopPropagation();
        window.location.href = links[i].href;
        return;
      }
    }

    function on_click(event){
      var image = document.getElementById("image");
      var w1 = img0.width;
      var h1 = img0.height;
      var xs = window.scrollX;
      var ys = window.scrollY;
      var x0 = img0.getBoundingClientRect().left + xs;
      var y0 = img0.getBoundingClientRect().top + ys;
      switch_scr();
      var w2 = img0.width;
      var h2 = img0.height;
      var kx = 1.0\*w2/w1;
      var ky = 1.0\*h2/h1;
      var xm  = event.clientX;
      var ym  = event.clientY;
      window.scroll(x0-xm + kx\*(xs-x0+xm), y0-ym + ky\*(ys-y0+ym));
    }

    document.addEventListener('keydown', process_key);    *if $opts{html_arrows};

  close JS;
}



#################################################################
#################################################################
### create index html
my $in_row=0;
my $np=0;
my $nh=0;

my $of = "$opts{basedir}/$opts{html}";
$of = '/dev/stdout' if $opts{html_stdout};
$of = "| $opts{html_filter} > $of" if $opts{html_filter};

## how to go from html index to image dir:
my $htmldir = "$opts{html}";
$htmldir =~ s/[^\/]*$//;
$htmldir =~ s|/+$||; # remove trailing /
my $htm2imgdir = rel_dir($htmldir, $opts{imgdir});

open OUT, "> $of" or die "Can't open $of: $!\n";
print STDERR "[Creating HTML index: $of]\n" if $opts{verbose};


sub write_pswp_data($){
  my $fd = shift;
print $fd qq*
<!-- PhotoSwipe data, added because of --pswp option was used -->
<div id=gallery class=pswp tabindex=-1 role=dialog area-hidden=true>
  <div class="pswp__bg"></div>
  <div class="pswp__scroll-wrap">
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <div class="pswp__counter"></div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <a href="" download class="ref_download">
        <button class="pswp__button btn_download" title="Download"></button></a>
        <button class="pswp__button btn_time"     title="Time"></button>
        <button class="pswp__button btn_map"      title="Map"></button>
        <button class="pswp__button btn_marks"    title="Marks on/off"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut"></div>
            </div>
          </div>
        </div>
      </div>
      <!--div class="pswp__loading-indicator"><div class="pswp__loading-indicator__line"></div></div-->
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
          <!-- <a href="#" class="pswp__share--facebook"></a>
               <a href="#" class="pswp__share--twitter"></a>
               <a href="#" class="pswp__share--pinterest"></a>
               <a href="#" download class="pswp__share--download"></a> -->
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>
      <div class="pswp__caption" align=left>
        <div class="pswp__caption__center" width=100% align=left></div>
      </div>
    </div>
  </div>
</div>
*;
print $fd qq*
<script>
var pswp;
function addphoto_open_pswp(i, el){

  // getBoundingClientRect works properly with IMG, not A.
  // switch to inner img
  for (let i = 0; el && i < el.children.length; i++) {
    if (el.children[i].tagName === 'IMG') { el = el.children[i]; break; }
  }

  // Define PhotoSwipe options
  // See: http://photoswipe.com/documentation/options.html
  var options = {
    index: i-1,
    getThumbBoundsFn: function(index) {
        // See Options->getThumbBoundsFn section of docs for more info
        if (!el) return;
        var rect = el.getBoundingClientRect();
        var pageYScroll = window.pageYOffset || document.documentElement.scrollTop;
        return {x:rect.left, y:rect.top + pageYScroll, w:rect.width};
    },
    addCaptionHTMLFn: function(item, captionEl, isFake) {
      captionEl.children[0].innerHTML = item.title;
      return true;
    },
  };
  if(!el) {
    options.showAnimationDuration = 0;
  }

  // Pass data to PhotoSwipe and initialize it
  var pswpElement = document.querySelectorAll('.pswp')[0];
  pswp = new PhotoSwipe(
    pswpElement, PhotoSwipeUI_Default, addphoto_images, options);

  // see: http://photoswipe.com/documentation/responsive-images.html
  var realViewportW, realViewportH,
      useLargeImages = false, firstResize = true, imageSrcWillChange;

  pswp.listen('beforeResize', function() {
    realViewportW = Math.min(document.documentElement.clientWidth, window.innerWidth || 1600);
  });

  pswp.listen('gettingData', function(index, item) {
    if (item.th2 != undefined && realViewportW < item.th2.w) {
      item.src = item.th2.src;
      item.w = item.th2.w;
      item.h = item.th2.h;
      return;
    }
    if (item.th1 != undefined && realViewportW < item.th1.w) {
      item.src = item.th1.src;
      item.w = item.th1.w;
      item.h = item.th1.h;
      return;
    }
    if (item.th1.src) {
      item.msrc = item.th1.src;
    }
    item.src = item.th0.src;
    item.w = item.th0.w;
    item.h = item.th0.h;
  });

  pswp.listen('afterChange', function(index) {
    var it = pswp.currItem;
    bp = document.getElementsByClassName("ref_download");
    if (bp.length){ bp[0].setAttribute('href', it.th0.src); }
    bp = document.getElementsByClassName("btn_time");
    if (bp.length){
      if (it.dat) {bp[0].setAttribute('title', it.dat);}
      else {bp[0].style.display = 'none';}
    }
    bp = document.getElementsByClassName("btn_map");
    if (bp.length){
      if (it.lat && it.lon){
        bp[0].style.display = '';
        bp[0].setAttribute('title', it.lat + "," + it.lon + ", " + it.alt || '');
        if (it.map){
          bp[0].setAttribute('onclick', "window.open('" + it.map + "');");
        }
      }
      else {bp[0].style.display = 'none';}
    }
    bp = document.getElementsByClassName("btn_marks");
    if (bp.length){
      if (pswp.currItem.ovl) {
        bp[0].style.display = '';
        bp[0].setAttribute('onclick', 'addphoto_switch_marks()');
      }
      else {bp[0].style.display = 'none';}
    }
  });
  pswp.init();
}

function addphoto_switch_marks() {
  el = pswp.currItem.ovlEl;
  if (!el) {return;}
  el.style.display = el.style.display == 'none'? '':'none';
}

// Parse URL hash and open pswp if it contains #pid
function addphoto_parse_hash() {
  var hash = window.location.hash.substring(1);
  var params = {};
  if(hash.length < 3) {return params;} // a=b
  var vars = hash.split('&');
  for (var i = 0; i < vars.length; i++) {
    if(!vars[i]) { continue; }
    var pair = vars[i].split('=');
    if(pair.length < 2) { continue; }
    params[pair[0]] = pair[1];
  }
  if(params.pid) {
    addphoto_open_pswp(params.pid);
  }
};
*;

  print $fd "addphoto_images=[\n";
  foreach my $ph (@ph){
    # paths of html page and thumbnail image from album index
    my $htm2img = $htm2imgdir . $ph->{imgdir2img};
    my $imgfile = $htm2img . $ph->{imgname};
    my $th1file = $htm2img . $ph->{th1name};
    my $th2file = $htm2img . $ph->{th2name};
    my $mrkfile = $htm2img . $ph->{mrkname};
    print  $fd "  {";
    print  $fd  "\n    th0: {src: \"$imgfile\", w:$ph->{img_w}, h:$ph->{img_h}}";
    print  $fd ",\n    th1: {src: \"$th1file\", w:$ph->{th1_w}, h:$ph->{th1_h}}" if $ph->{use_th1};
    print  $fd ",\n    th2: {src: \"$th2file\", w:$ph->{th2_w}, h:$ph->{th2_h}}" if $ph->{use_th2};
    print  $fd ",\n    ovl: \"$mrkfile\"" if $ph->{use_mrk};
    print  $fd ",\n    title: \"$ph->{title}\"" if $ph->{title};
    print  $fd ",\n    dat: \"$ph->{time}\"" if $ph->{time};
    printf $fd ",\n    alt: %.1f", $ph->{alt} if $ph->{alt};
    printf $fd ",\n    lat: %.6f", $ph->{lat} if $ph->{lat};
    printf $fd ",\n    lon: %.6f", $ph->{lon} if $ph->{lon};
    printf $fd ",\n    map: \"%s\"", crd_url($ph->{lat}, $ph->{lon}, $ph->{imgname}) if $ph->{lat} ||$ph->{lon};
    print  $fd "\n  },\n";
  }
  print $fd "];\n";

print $fd qq*
addphoto_parse_hash();
</script>
<!-- end of PhotoSwipe data -->
*;
}

foreach my $b (@data){
  if ($b->{type} eq 'photo') {
    $np++;
    my ($img, $title) = (${$b->{files}}[0], $b->{title});

    write_pswp_data(*OUT) if $np==1 && $opts{pswp};

    # paths from html index
    my $htm2img = $htm2imgdir . $b->{imgdir2img};
    my $imgfile = $htm2img . $b->{imgname};
    my $htmfile = $htm2img . $b->{htmname};
    my $th1file = $htm2img . $b->{th1name};
    my $th2file = $htm2img . $b->{th2name};
    my $mrkfile = $htm2img . $b->{mrkname};
    # what to use in the index:
    my $th_file = $b->{use_th1} ? $th1file : ($b->{use_th2} ? $th2file : $imgfile);

    # get size of small thumbnail (it can be missing if use_th1==0!)
    unless ($b->{th1_w} && $b->{th1_h}) {
      my $ret;
      ($ret, $b->{th1_w}, $b->{th1_h}) =
      split(/\s+/, `ph_resize --scale "$opts{th1_size}" --dryrun --printres "$b->{imgpath}" /dev/null`);
    }

    # open a row only if align = center
    if ($b->{align} eq 'center') {
      print OUT "<div class=addphoto-row>\n" unless $in_row;
      $in_row=1;
    } else {
      print OUT "</div>\n" if $in_row; # close row
      $in_row=0;
    }
    my $a_attrs=" name='ph$np'";
    if (!$opts{pswp}){
      if ($opts{nohtm}) { $a_attrs .= " href='$imgfile'"; }
      else              { $a_attrs .= " href='$htmfile'"; }
    }
    else {
      $a_attrs .= " onclick='addphoto_open_pswp($np, this)'";
    }

    print OUT "<div class=addphoto-img-$b->{align}><a$a_attrs>\n";
    print OUT "<img src='$th_file' alt='$b->{atitle}'" .
              " width=$b->{th1_w} height=$b->{th1_h}".
              " class=addphoto-th></a>\n";
    print OUT "<br><div class=addphoto-caption style='width:$b->{th1_w}px'>$b->{title}</div>\n";
    print OUT "</div>\n";
  }
  else{
    print OUT "</div>\n" if $in_row; # close row
    $in_row=0;
    if ($b->{type} eq 'head'){ # \h commands
      $nh++;
      my ($depth, $title, $ruler) = ($b->{depth}, $b->{title}, $b->{ruler});
      print OUT ($ruler?'<hr>':'') .
        "<a name='h" . $nh . "'></a><h$depth>$title</h$depth>\n";
      next;
    }
    if ($b->{type} eq 'toc'){
      html_toc(*OUT, \@data);
      next;
    }
    if ($b->{type} eq 'text'){
      print OUT $b->{text};
      next;
    }
  }
}
print OUT "</div>\n" if $in_row; # close row
close OUT;



print STDERR "[Done: $np photos, $nh headers]\n" if $opts{verbose};

__END__

=head1 NAME

addphoto2 -- create html photoalbums from text templates

=head1 SYNOPSIS

$0 <options> <infile>

=head1 OPTIONS

=over 2

=item h|help          -- print help message

=item v|verbose:1     -- be verbose

=item D|imgdir=s      -- image dir (relative to index file location, default .)

=item H|html=s        -- html file (relative to index file location)

=item html_filter=s   -- filter for index html

=item html_stdout:1   -- print index html to stdout instead of writing to file. html option is still needed.

=item I|init          -- INIT MODE: create index file

=item J|init_only     -- create index file and exit

=item T|init_tsort:1  -- init mode: sort photos by time

=item d|init_days:1   -- init mode: add day headers

=item r|init_rec:1    -- init mode: find files recursively

=item w|init_width=i  -- init mode: max page width

=item init_img_mask=s -- init mode: mask for finding images

=item init_index_head=s -- init mode: head for the index file

=item init_index_tail=s -- init mode: tail for the index file

=item C|cleanup       -- CLEANUP MODE: remove unused files and exit

=item f|force:1       -- cleanup mode: do not ask before deleting files

=item dryrun:1        -- cleanup mode: do not delete files

=item th1_pref=s      -- Small thumbnail prefix (can end with /), empty for no thumbnails

=item th1_size=s      -- Small thumbnail size (S1:S2:S3, see elsewhere)

=item th1_rm_exif:1   -- Remove exif-data from small thumbnails (default)

=item th2_pref=s      -- Large thumbnail prefix (can and with /), empty for no thumbnails

=item th2_size=s      -- Large thumbnail size (S1:S2:S3, see elsewhere)

=item th2_rm_exif:1   -- Remove exif-data from large thumbnails (default)

=item mark_pref=s     -- Image marks prefix (can and with /), empty for no marks

=item html_pref=s     -- Image marks prefix (can and with /), empty for no marks

=item nohtml:1        -- Do not generate hmtl pages for images

=item mstyle=s        -- Mark style

=item l|lang:1        -- Language support

=item pswp:1          -- PhotoSwipe support

=item quality=i       -- Jpeg quality for thumbnails (default 90)

=item map_ref=s       -- Map link style (gmap, nakarte)

=item map_zoom=i      -- Map link zoom (default 6)

=item fig_lang=s      -- fig language

=item fig_res=f       -- fig resolution

=item html_charset=s  -- add meta charset tag in html pages (not in index html)

=item html_viewport:1 -- add meta viewport tag in html pages (not in index html)

=item html_screen_sw:1 -- add fit to screen switch to html pages

=item html_arrows:1   -- add navigation (including left/right arrows) to html pages

=item html_resize:1   -- resizable images in html pages (default state of "size" button)

=back

=head1 DESCRIPTION

=head2 Files and directories

=over 2

=item B<Index file.> It contains the album structure: list of images,
text, configuration. Name of index file is taken from an argument
of the program. In init mode (-I,--init option) index file is created
(old one is moved to *.bak if it exists). In other modes the index file
should exist.

=item B<Image folder.> Folder for all album images and other files. It is
specified in I<--imgdir> option as a relative path from location of the
index file. Default value is '.'. Paths of all album images are counted
from this folder.

If a folder name is given to a program instead of index file the
B<Image folder> is set to this name and B<Index file> name is
foremed by adding .txt to this name.

=item B<HTML-file.> File for html code of the album. File is always
overwritten by the program. Specified by I<--html> option as a relative
path counted from location of the index file. Default name is created
from the index file name by removing last extension (if it exists) and
adding '.htm' instead.

=item B<Image files.> In init mode (-I,--init option) program finds and
write into the index file all image files located in the image folder
(default) and in all subfolders (with -r, --recursive option). In the
index file one can use any path to the image, relative to the image
folder.

=item B<Thumbnails.>There are two sizes of thumbnail images.
Names for thumbnail images are made from image names
by adding a prefix which can be set by options --th1_pref (for small thumbnails),
--th2_pref (for large thumbnails). If the prefix ends with '/' then
thumbnails are locates in a subfolder. Sizes of thumbnails are set by
--th1_size and --th2_size options (in W1:W2:W3 format, see elsewhere).

=item B<Marks.>Marks are made from a fig file located near the image
file. Names for a mark image is made from the image name by adding a
prefix which can be set by options --mark_pref. If the prefix ends with
'/' then marks are locates in a subfolder.

=back


=head2 Init mode

Init mode starts if B<-I,--init> or B<-J,--init_only> option is set. In this
mode a new index file is created with all images located in the image
folder. Then the normal mode is started (if the option was --init).
Options:

=over 2

=item  I|init           -- INIT MODE: create index file

=item  J|init_only      -- create index file and exit

=item  T|init_tsort:1   -- init mode: sort photos by time

=item  d|init_days:1    -- init mode: add day headers

=item  r|init_rec:1     -- init mode: find files recursively

=item  w|init_width=i   -- init mode: max page width

=item  init_img_mask=s  -- init mode: mask for finding images

=item  init_index_head=s -- init mode: head for the index file

=item  init_index_tail=s -- init mode: tail for the index file

=back


=head2 Input file syntax:

Commands are started at the beginning of line with '\' symbol.
Other lines copied without changes. Commands:

=over 2

=item \photo  <file> <title>     -- photo

=item \photo[r|l] <file> <title> -- left/right aligned photo

=item \photo  <file1>,<file2>,... <title>     -- multiple photos on a single page

=item \h(1|2|3|4)[r] <title>     -- header, 'r' for ruler above it

=item \toc                       -- table of contents

=item \end                       -- stop processing file

=item \#                         -- comment line

=item \\<any text>               -- put '\' at the beginning of the line.

=item \\set <name> <value>       -- set an option.

=item \\keep <file pattern> ...  -- keep additional files during the cleanup mode

=back

Report bugs to <slazav\@altlinux.org>

=cut
